[/ -*- coding: utf-8-unix  -*- ]

[library Documentação do Assistant C++
    [quickbook 1.5]
    [version 2.0.0.1]
    [id assistant]
    [copyright 2012-2013 TecGraf/PUC-Rio]
    [authors [Almeida, Felipe Magno]]
    [/ license ]
    [source-mode c++]
]

[/include auto_index_helpers.qbk]

[def __Assistant__ [link assistant Assistant]]
[def __Openbus__ Openbus]
[def __BoostParameters__ [@http://www.boost.org/doc/libs/1_51_0/libs/parameter/doc/html/index.html
Boost.Parameter] ]
[def __BoostThread__ [@http://www.boost.org/doc/libs/1_51_0/doc/html/thread.html
Boost.Thread] ]
[def __BoostChrono__ [@http://www.boost.org/doc/libs/1_51_0/doc/html/chrono.html
Boost.Chrono] ]
[def __BoostSystem__ [@http://www.boost.org/doc/libs/1_51_0/libs/system/doc/index.html
Boost.System] ]
[def __SharedAuthentication__ ['Shared Authentication]]
[def __MICO__ ['Mico]]
[def __CORBA__ ['CORBA]]
[def __SCS__ ['SCS]]
[def __TypeCode__ ['TypeCode]]
[def __Cadeias__ [link Cadeias Cadeias]]
[def __DownloadSDK__ [@https://jira.tecgraf.puc-rio.br/confluence/display/OPENBUS020/SDK Download]]

[section Introdução]

Esse manual oferece uma visão geral de implementação de serviços com
uso do barramento __Openbus__, assim como a explicação de várias
características e opções. Os seguintes conhecimentos são assumidos pelo
documento:

* Linguagem C++
* CORBA
* Modelo de Componentes SCS

A proposta do manual é capacitar o indivíduo, que atenda aos
pré-requisitos do documento, a escrever serviços para o barramento
__Openbus__ dentro do escopo dessa API.

[endsect]

[section Instalação]

Para usar o SDK, primeiro você precisa fazer o seu
__DownloadSDK__. Baixe a versão binária que seja mais próxima de sua
configuração e descompacte-a em alguma pasta aonde será feito o
seu desenvolvimento.

[section Dependencias]

Para usar o __Assistant__, você precisa ligar sua aplicação com as
seguintes bibliotecas:

* OpenSSL
* Mico
* SCS
* Biblioteca de Log
* __BoostThread__
* __BoostChrono__
* __BoostSystem__
* API Básica do Openbus
* Assistant

[endsect]

[section Nomenclatura]

Os arquivos e diretórios tem o seguinte padrão de nomenclatura, com exceção da biblioteca OpenSSL:

[table Padrão de nomenclatura de bibliotecas
  [[Simbolo] [Descrição]]
  [
        [`-mico`]
[Se a biblioteca for compilada para o ORB Mico. É o caso para todas as bibliotecas que usam CORBA na versão 2.0.0 do Openbus. É possível que outros ORBs venham a ser suportados no futuro.]
  ]
  [
        [`-mt`]
[Se a biblioteca for compilada com suporte a múltiplas threads]
  ]
  [
        [`-s`]
[Se a biblioteca for compilada estaticamente. Em linux isso também significa que o arquivo termina em `.a` ao invés de `.so`, e em Windows a biblioteca dinâmica possui tanto um arquivo de extensão `.lib` como de extensão `.dll`]
  ]
  [
        [`-d`]
[Se a biblioteca for compilada com simbolos de debug e sem otimização.]
  ]
]

Dessa forma, a biblioteca da API básica compilada em multithread, com debug e em compilação estática teria o nome, no linux: `libopenbus-mico-mt-s-d.a`.

Para a biblioteca MICO, como não definimos seu processo de compilação, ele não segue esse mesmo padrão. Porém, para que os vários binários, resultado da compilação do mico, não conflitem um com o outro, separamos eles em diretórios diferentes. O nome desses diretórios seguem esse padrão. Portanto, o caminho, no pacote binário do __Assistant__, encontramos a biblioteca MICO, compilada para multithread, em static e com debug em: `lib/mico-mt-d/mico-2.3.13.a`. Veja que no nome do diretório, o `-s` não aparece. Isso é porque a compilação é feita em conjunto entre static e shared e o resultado dessa compilação é colocado na mesma pasta.

[endsect]

[section Macros]

Algumas macros personalizam o comportamento da biblioteca de acesso padrão e do __Assistant__. Algumas são opcionais, e outras obrigatórias para que os headers possam levar determinada configuração em conta. Iremos aqui documentar, também as macros de todos os projetos desenvolvidos no Openbus que são dependencia do __Assistant__.

[table Padrão de nomenclatura de bibliotecas
  [[Projeto] [Macro] [Descrição]]
  [
        [Logger - Biblioteca de Log]
        [`LOGGER_DISABLE_THREADS`]
        [Macro que deve ser definida sempre que usando um dos pacotes da biblioteca logger sem o prefixo `-mt`. Desabilita sua dependência com a biblioteca __BoostThread__ e não leva em consideração acesso concorrente aos loggers.]
  ]               
  [
        [SCS]
        [`SCS_THREADING_ENABLED`]
        [Macro que deve ser definida sempre que usando um dos pacotes da biblioteca SCS com o prefixo `-mt`. Cria a dependência do SCS a biblioteca __BoostThread__ e assegura o uso concorrente de um ComponentContext por multiplas threads e o acesso concorrente às facetas básicas por chamadas simultâneos pelo ORB.]
  ]
  [
        [API Básica]
        [`OPENBUS_SDK_MULTITHREAD`]
        [Macro que deve ser definida sempre que usando um dos pacotes da biblioteca Openbus com o prefixo `-mt`. Assegura o uso concorrente da biblioteca pelo ORB e pelo usuário.]
  ]
  [
        [__Assistant__]
        [`ASSISTANT_SDK_MULTITHREAD`]
        [Macro que deve ser definida sempre que usando um dos pacotes da biblioteca __Assistant__ com o prefixo `-mt`. Cria a dependência do __Assistant__ à biblioteca __BoostThread__ e assegura o uso concorrente da biblioteca pelo ORB e pelo usuário.]
  ]
  [
        [__Assistant__]
        [`OPENBUS_ASSISTANT_DISABLE_NAMED_PARAMETERS`]
        [Macro que pode ser definida para eliminar a dependência do __Assistant__ com a biblioteca __BoostParameters__. Remove a interface de Named Parameters do construtor de [classref openbus::assistant::Assistant].]
  ]
]

[endsect]

[section Compilação do demo Hello]

Iremos aqui fazer a construção de um `Makefile` que faça a compilação
do demo Hello usando a configuração multithread, static e com
debug. Usaremos o compilador gcc como exemplo.


[important A construção desse
`Makefile` não representa uma indicação de como fazer o build de
código de cliente usando o __Assistant__. É apenas uma demonstração
que serve como documentação para que o usuário se sinta mais
confortável ao incluir o Openbus no seu próprio sistema de build,
levando em consideração quais bibliotecas deve selecionar para
determinada configuração e quais macros devem estar definidas em
seu próprio código para fazer uso da biblioteca de acesso do Openbus.]

Primeiramente, encontramos no pacote o demo hello no caminho `demo/hello`.
Lá, temos as seguintes pastas:

[table Árvore do demo Hello
  [[Diretório] [Descrição]]
  [
    [`bin`]
    [Se o pacote contiver os demos compilados]
  ]
  [
    [`server`]
    [Diretório que contém o arquivo `server.cpp`. Código fonte do servidor do demo Hello]
  ]
  [
    [`client`]
    [Diretório que contém o arquivo `client.cpp`. Código fonte do cliente do demo Hello]
  ]
  [
    [`idl`]
    [Diretório que contém o arquivo `hello.idl`. Interface usada para comunicação CORBA entre cliente e servidor.]
  ]
]

Para compilarmos o demo, precisamos antes compilar a IDL `hello.idl` e
os arquivos `client.cpp` e `server.cpp` e depois ligar os
intermediários com as bibliotecas nos executáveis finais `client` e
`server`.

[import demo-hello.mak]

[demo_hello_mak_compile_idl]

Esse comando faz a compilação de `hello.idl` para `bin/hello.cc` e
`bin/hello.h` com os stubs da interface CORBA, que serão usados nos
códigos fontes `server/server.cpp` e `client/client.cpp`. Usamos aqui
as variáveis `MICO_BIN` e `MICO_LIB` para parametrizar a localização
da biblioteca compartilhada do mico e o diretório aonde estão as
ferramentas do mico, como o compilador idl.

Veja que, o compilador idl do mico, faz uso de outra ferramenta
chamada mico-cpp, que se encontra no mesmo diretório que o próprio
compilador idl. Por isso, definimos a variável de ambiente `PATH` com
o caminho para o compilador IDL, para que o mesmo possa encontrar a
ferramenta `mico-cpp`.

Também, o compilador IDL depende da biblioteca compartilhada do
próprio mico. E então definimos a variável de ambiente LD_LIBRARY_PATH
com o caminho para a mesma.

Os parâmetros de linha de comando `--typecode`, `--poa` e `--no-paths`
significam respectivamente:

[table Parâmetros de linha de comando básicos do compilador IDL
       [[Parâmetro][Descrição]]
       [
        [`--typecode`]
        [Faz geração de código para os objetos globais de typecode de cada interface gerada pelo compilador IDL]
       ]
       [
        [`--poa`]
        [Faz geração de código para uso do Portable Object Adapter]
       ]
       [
        [`--no-paths`]
        [Não leva em consideração o caminho dos arquivos para construção das directivas de `#include` no código gerado]
       ]
]

Como sabemos nossa configuração, podemos definir as variáveis `MICO_LIB` e `MICO_BIN` para o seguinte no início de nosso Makefile

[demo_hello_mak_set_mico_bin]

A variável `CURDIR` é uma variável especial para o make que representa
o path corrente de onde o make foi executado. Estamos aqui assumindo
que o Makefile está sendo construído dentro do diretório do demo. Como
as pastas `bin` e `lib` se encontram na raiz do pacote, precisamos
voltar dois diretórios, e como estamos usando a configuração
multithread, static e debug, o diretório do mico é então `mico-mt-d`.

Para compilação do servidor para um arquivo objeto, intermediário, fazemos
o seguinte

[demo_hello_mak_compile_server_cpp]

Para compilarmos o `server/server.cpp`, precisamos do header
`bin/hello.h` já gerado pelo compilador IDL. Porém, não alimentamos o
header no comando de compilação. O simbolo `$<` é um simbolo especial
que expande para a primeira dependencia, no caso
`server/server.cpp`. Enquanto que o simbolo `$@` expande para o alvo,
que no caso é `bin/server.o`. Definimos também a variável CXXFLAGS,
que deverá conter todos os parâmetros de compilação que deverão ser
passados ao compilador, como os caminhos de inclusão, e etc.

Agora, atribuimos então à variável `CXXFLAGS`

[demo_hello_mak_set_cxxflags]

Adicionamos o diretório de include do mico de configuração que
queremos, e então os includes de cada projeto que está também no
pacote. Como iremos compilar em debug, não estamos usando nenhuma
otimização, passando `-O0`, e passando `-g` para inclusão de simbolos
de depuração na compilação do demo.

Também fazemos a definição das macros `OPENBUS_SDK_MULTITHREAD` e
`SCS_THREADING_ENABLED` pois estamos compilando a versão multithread
do demo. Porém, não fazemos a definição de `ASSISTANT_SDK_MULTITHREAD`
pois o código dessa demo não faz uso do __Assistant__.

E para a compilação do cliente, fazemos o mesmo que na compilação do
servidor, mas trocando o arquivo alvo e o arquivo fonte:

[demo_hello_mak_compile_client_cpp]

Assim, temos a compilação dos arquivos `server.cpp` e `client.cpp` e a
compilação da idl `hello.idl`. Falta ainda fazer a compilação dos stubs
para arquivo objeto também.

[demo_hello_mak_compile_hello_cc]

Agora temos todos os arquivos objetos que precisamos para gerar os
executáveis, falta apenas fazer o ligamento dos objetos com as
dependências e gerar o executável final do servidor e cliente:

[demo_hello_mak_binaries]

O simbolo `$^` representa todas as dependencias, queremos fazer o
ligamento de todos os dois objetos, e não fazer uso apenas do primeiro
como estávamos fazendo na compilação. Também, acrescentamos a variável
`LDFLAGS`, que deve conter as flags de ligamento que serão passadas ao
ligador. Elas devem incluir as bibliotecas que serão ligadas, e levar
em conta a configuração que se deseja gerar, para pegar as versões
corretas de cada dependência.

[demo_hello_mak_set_ldflags]

Passamos, com o parâmetro `-L`, dois diretórios de busca de
bibliotecas. Uma do mico da configuração que queremos, e o outro de
todo o diretório lib do pacote com as outras bibliotecas.

Passamos o resto dos argumentos diretamente ao ligador com a opção
`-Wl` e como nossa configuração final é de ligamento estático,
passamos também a opção `-Bstatic` para determinar que estamos
querendo somente as versões estáticas das bibliotecas, e então
passamos uma a uma as dependências, usando o padrão de nomenclatura
no início do documento.

Para finalizar, definimos o alvo chamado `all`, que irá construir os dois executáveis.

[demo_hello_mak_all]

E então podemos compilar o demo fazendo um `make all`

[endsect]

[endsect]

[section Escopo]

__Assistant__ é o nome de uma abstração da biblioteca de acesso do
__Openbus__. Ela visa facilitar os recursos mais utilizados pelos
clientes do barramento. Para atingir esse objetivo, alguns sacrifícios
foram feitos e portanto o __Assistant__ não é tão flexível quanto o
uso direto da API básica, mas atende a maioria dos casos de usos
involvendo o barramento __Openbus__.

[section Aplicações no Assistant]

As aplicações mais comuns, e as que são melhores implementadas usando
o __Assistant__ tem o seguinte em comum:

* Se comunica com um único barramento
* Possui apenas uma autenticação com o barramento

Geralmente um aplicativo que se conecta ao barramento é um de dois
tipos, ou um híbrido:

* Servidor
* Cliente

Um servidor adiciona ofertas no barramento, disponibilizando um ou
mais serviços através destas ofertas. Um cliente, pelo outro lado,
consulta o barramento por ofertas de serviços que deseja consumir.

[endsect]

[section O que o Assistant não faz]

Por ser uma abstração mais simples e focada em um grupo de casos de
uso, naturalmente o __Assistant__ não consegue resolver todos os
problemas que a API básica, da qual o __Assistant__ é implementado,
pode.

Portanto, os seguintes casos só conseguem ser implementados com uso da
API básica:

* Se comunica com mais de um barramento
* Faz uso de mais de um ORB
* Possui múltiplas identidades com um ou mais barramentos

O __Assistant__ recebe as informações de autenticação como usuário,
senha, chave privada, etc, na construção do __Assistant__, assim
como outras informações necessárias para uso de CORBA.

Com essas informações, o __Assistant__ se autentica com o barramento,
de forma assíncrona e mantém válida essa autenticação, renovando a
autenticação quando esta expira. Também é refeita a autenticação se a
mesma ficar inválida por qualquer outro motivo, como por remoção
através de ferramentas de governança do barramento __Openbus__.

[warning A construção do __Assistant__ não implica que a autenticação
já tenha ocorrido com sucesso. O que significa que funções sincronas,
como findServices podem falhar com a exceção NO_PERMISSION por não
estar ainda autenticado com o barramento __Openbus__]

[endsect]

[section Vantagens de usar o Assistant]

Para as aplicações que estão no escopo do __Assistant__, usar o
__Assistant__ possui várias vantagens. Dentre as principais:

* Autenticação simplificada com o barramento
* Tratamento automático de erros
* Manter serviços ofertados

Como foi dito anteriormente, a autenticação ocorre de forma
assíncrona. O mesmo ocorre com o registro de ofertas. Essa diferença
entre __Assistant__ e a API básica é crucial para entender as
vantagens de se usar o __Assistant__.

O registro de oferta ocorre de forma assíncrona e se por qualquer
motivo o registro se perder, como por perder autenticação com o
barramento, o __Assistant__ automaticamente faz um novo registro de
oferta. Assim, o usuário não precisa se preocupar com os vários casos
de erros que possam acontecer num sistema distribuido para garantir
que suas ofertas estão visiveis para outros serviços.

Para funções que são sincronas, como as que se espera um retorno, como
busca por ofertas. O __Assistant__ recebe também um parâmetro de
número de tentativas, assim o usuário pode usar o tratamento de erro
automático do __Assistant__ para essas chamadas remotas, que podem
falhar por inúmeros motivos.

[endsect]

[endsect]

[section Desenvolvimento]

Prover um serviço no __Openbus__ usando o __Assistant__ é bem
simples. Para isso, precisamos construir uma instância da classe
__Assistant__ que nos proverá as funções necessárias para ofertar
serviços no barramento.

Em C++ instancia-se a classe [classref openbus::assistant::Assistant] usando,
preferencialmente, ['named parameters].

[section Named Parameters]

['Named Parameters] é uma forma de passagem de argumentos, aonde cada
argumento e parâmetro é casado no ponto de chamada. Um exemplo
hipotético de ['named parameters] seria o seguinte:

[import namedparameters.cpp]
[namedparameters]

[note No __Assistant__ todos os parâmetros começam com um
['underscore], esse é o padrão seguido pela biblioteca 
__BoostParameters__ que é usada no __Assistant__]

Os seguintes parâmetros existem no __Assistant__:

[table Named parameters existentes no Assistant
  [[Parametros] [Descrição]]
  [
        [`_host`]
[Nome do ['host] aonde se encontra o barramento. Conteúdo deste ['named parameter] é obrigatório. Pode ser passado com ['named parameter] ou como
primeiro argumento do construtor do [classref openbus::assistant::Assistant].]
  ]
  [
        [`_port`]
[Porta TCP de onde se encontra o barramento. Conteúdo deste ['named parameter] é obrigatório. Pode ser passado com ['named parameter] ou como
segundo argumento do construtor do [classref openbus::assistant::Assistant].]
  ]
  [
        [`_username`]
[Nome do usuário para autenticação ao barramento. Esse parâmetro deve ser usado quando se pretende fazer uma autenticação
por usuário e senha. Deve sempre ser usado junto com o ['named parameter] _password.]
  ]
  [
        [`_password`]
[Senha de autenticação. Esse parâmetro deve ser usado quando se pretende fazer uma autenticação por usuário e senha.
Deve sempre ser usado junto com o ['named parameter] _username.]
  ]
  [
        [`_entity`]
[Nome da entidade registrada por certificado no barramento. Esse parâmetro deve ser usado quando se pretende
fazer uma autenticação por certificado. Deve sempre ser usado junto com um dos dois ['named parameters] _private_key
ou _private_key_filename.]
  ]
  [
        [`_private_key`]
[Conteúdo de chave privada usada para criação do certificado registrado no barramento. Esse parâmetro deve ser usado quando se
pretende fazer uma autenticação por certificado. Seu tipo deve ser um [classref openbus::PrivateKey]. Deve sempre ser usado com o ['named parameter] _entity.]
  ]
  [
        [`_private_key_filename`]
[Nome do arquivo que contém a chave privada usada para criação do certificado registrado no barramento. Esse parâmetro deve
ser usado quando se
pretende fazer uma autenticação por certificado. O conteúdo deste arquivo deve ser de uma
chave privada gerada com o ['shell script] openssl-generate.sh. Deve sempre ser usado com o ['named parameter] _entity.]
  ]
  [
        [`_shared_auth_callback`]
[['Function object] de assinatura `std::pair<LoginProcess, CORBA::OctetSeq>()`. Esse ['function object] deve
retornar um par contendo um `LoginProcess` e um segredo em `CORBA::OctetSeq` que tenham sido retornados
por um `startSharedAuth` sobre uma conexão com o mesmo barramento. Essa função pode ser chamada mais de uma vez,
e o seu retorno não deve se repetir, já que o objeto `LoginProcess` só é válido ao ser usado pela primeira vez.]
  ]
  [
        [`_retry_wait`]
[Número de segundos de espera em caso de erros. Esse argumento modifica o tempo entre tentativas de operações
com o barramento.]
  ]
  [
        [`_log_level`]
[Nível de log utilizado pela implementação do __Assistant__ em sua execução. Os níveis existentes, em ordem crescente de verbosidade, são: `::logger::disabled_level`, `::logger::error_level`, `::logger::warning_level`, `::logger::info_level` e
`::logger::debug_level`.]
  ]
  [
        [`_argc`]
[Número de argumentos no ['array] passado em _argv. Esse parâmetro é usado para passar o par argc e argv
da função `int main(int argc, char* argv[])` para o ORB. Isso permite que o usuário do aplicativo configure
algumas características do ORB por linha de comando do aplicativo. Deve ser usado em conjunto com ['named parameter] _argv.
Esse argumento pode ser modificado pelo ORB.]
  ]
  [
        [`_argv`]
[['Array] de argumentos de linha de comando. Esse parâmetro é usado para passar o par argc e argv
da função `int main(int argc, char* argv[])` para o ORB. Isso permite que o usuário do aplicativo configure
algumas características do ORB por linha de comando do aplicativo. Deve ser usado em conjunto com ['named parameter] _argc,
que indica o número de argumentos que contém o array. Esse argumento pode ser modificado pelo ORB.]
  ]
  [
        [`_on_login_error`]
[['Polymorphic function object] de tratamento de erros de ['login]. O ['function object] passado como argumento deve ter um operador de chamada polimórfico com um parâmetro. O argumento passado é a exceção que foi tratatada pelo __Assistant__.
[note Essa função deve receber o argumento por referência para objeto constante para evitar uma cópia, que pode causar um problema de slicing da exceção.]
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
  [
        [`_on_register_error`]
[['Polymorphic function object] de tratamento de erros de registro de ofertas. O ['function object] passado como argumento deve ter
 um operador de chamada polimórfico com três parâmetros. A assinatura deve ser do tipo `void(IComponent_var, ServicePropertySeq, Error const&)`, aonde `Error` é um tipo parametrizado, um `typename` de uma `template`. O argumento `IComponent_var` é a referência CORBA
usada para tentativa de registro; o argumento `ServicePropertySeq` é o conjunto de propriedades a serem registradas
na oferta e o argumento `Error` passado é a exceção que foi tratatada pelo __Assistant__ durante o erro.
[note Essa função deve receber o argumento Error por referência para objeto constante para evitar uma cópia, que pode causar um problema de slicing da exceção.]
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
  [
        [`_on_fatal_error`]
[['Polymorphic function object] de tratamento de erros fatais. O ['function object] passado como argumento deve ter
um operador de chamada polimórfico com um parâmetro. O argumento passado é a exceção que foi tratatada pelo __Assistant__ durante o erro.
[note Essa função deve receber o argumento por referência para objeto constante para evitar uma cópia, que pode causar um problema de slicing da exceção.]
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
]

Os parâmetros `_host` e `_port` são obrigatórios, e portanto é possível passar os argumentos sem referenciar os parâmetros, apenas passando-os como os primeiros argumentos na construção do __Assistant__, da seguinte forma:

[import namedparameters_host_port.cpp]
[namedparameters_host_port]

[caution Se o seu compilador não suportar __BoostParameters__, então é
possível definir a macro `OPENBUS_ASSISTANT_DISABLE_NAMED_PARAMETERS`
na compilação do projeto e usar uma das funções `createWithPassword`,
`createWithPrivateKey` ou `createWithSharedAuth` para criar o
__Assistant__]

[endsect]

[section Autenticando no barramento]

Como vimos nos parâmetros disponíveis para construção do
__Assistant__, temos disponíveis três métodos de autenticação:

* Por usuário e senha
* Por certificado, com chave privada
* Por __SharedAuthentication__

[section Autenticação por usuário e senha]

A autenticação por usuário e senha se faz com os parâmetros
`_username` e `_password`.

[import auth_user.cpp]
[auth_user]

Como vimos anteriormente, após a construção de
[classref openbus::assistant::Assistant], a autenticação não necessariamente já
ocorreu, pois a mesma é feita assincronamente e pode se repetir
indefinidamente, sem intervenção do usuário. O __Assistant__ assume
que o cliente pretende se manter logado por todo o tempo em que o
__Assistant__ se mantiver vivo. E por isso em qualquer erro que
implique na perda de autenticação o __Assistant__ tratará-lo tentando
se autenticar novamente até conseguir. Esse é uma das principais
vantagens de se usar o __Assistant__.

[endsect]

[section Autenticação por chave privada]

Existem duas formas de se autenticar por chave privada no __Assistant__
do C++:

* Passando um [classref openbus::PrivateKey] como argumento
* Passando como argumento o nome do arquivo da chave

Nem sempre a chave se encontra em um arquivo, como por exemplo no caso
de construção de uma chave privada dinamicamente, ou recebida por
algum método de IPC. Neste caso faz mais sentido usar [classref
openbus::PrivateKey] com um de seus construtores.

[import auth_private_key.cpp]
[auth_private_key]

Porém, se a chave estiver em um arquivo seria muito mais fácil passar
o nome do arquivo do que fazer a leitura do mesmo em um
OctetSeq. Neste caso é só usar o parâmetro `_private_key_filename`:

[import auth_private_key_file.cpp]
[auth_private_key_file]

[endsect]

[endsect]

[section Registrando ofertas]

O propósito principal do __Assistant__ para um servidor, é o de
autenticar ao barramento __Openbus__ e ofertar os serviços no Registro
de Ofertas.

Primeiramente fazemos o `#include` do ['header] do __Assistant__ para
que possamos construir um [classref openbus::assistant::Assistant].

[import offers.cpp]
[create_offers_include]

Feito isto, podemos instanciar a classe [classref
openbus::assistant::Assistant], que cuidará da autenticação por nós:

[create_offers_auth]

Se formos ofertar algum serviço, esse serviço precisa estar definido
em alguma IDL. Usaremos como base a seguinte IDL, que não poderia ser
mais simples:

[import hello.idl]
[say_hello_idl]

Dada esta IDL, precisamos fazer o `#include` do ['header] do ['stub]
gerado pelo __MICO__ e fazer a implementação de seu ['Servant].

[create_offers_include_hello]

[note Estamos usando como padrão neste documento que os ['stubs]
gerados pelo compilador IDL do __MICO__ se encontrem em um diretório
chamado ['stubs], porém, essa é apenas um padrão de uso e para
projetos mais simples não é necessário e nem sempre vantajoso separar
este header de outros, dependendo de qual sistema de ['build] se está
usando]

E então a construção do ['Servant] __CORBA__:

[create_offers_servant_hello]

Definido o ['Servant], fazemos sua instanciação para inclusão em um
componente __SCS__,que será finalmente ofertado no barramento:

[create_offers_instantiate_servant_hello]

[note Por não haver necessidade de alocação dinâmica, instanciamos o
['Servant] na ['automatic storage], aonde o objeto será desalocado
automaticamente no fim de seu escopo. Facilitando o raciocínio sobre o
software, assim como elimina uma possibilidade de memory leak]

Instanciado o ['Servant], podemos incluir este como faceta do
componente que será ofertado, mas para isto primeiro o componente
precisa ser também instanciado:

[create_offers_instantiate_component]

E então a faceta adicionada:

[create_offers_add_facet]

[note Usamos aqui o objeto de __TypeCode__ para retornar o ['RepoID]
da nossa interface `Hello`. Assim diminuimos uma redundância e
adicionamos uma checagem estática se o nome da classe mudar. Porém, é
necessário lembrar de passar o parâmetro `--typecode` para o
compilador IDL do __MICO__]

Vejamos nosso pequeno servidor como fica ao criar o componente com
nossa faceta:

[create_offers_component_created]

Agora só nos resta registrar o serviço e passar a linha de execução
para o __ORB__. Registrando o serviço:

[create_offers_register_service]

E chamando `run()` no __ORB__:

[create_offers_run]

E assim terminamos a construção de nosso pequeno serviço ofertado no
barramento:

[create_offers]

[endsect]

[section Buscando ofertas no barramento]

[import searching_offers.cpp]

Já criamos o servidor, agora para completar é necessário construir um
consumidor deste serviço. Alguém que irá buscar esse serviço no
Registro de Ofertas e chamar `sayHello()`, que é o que nosso serviço
atualmente faz.

Para tal, precisamos, assim como no servidor, autenticar-nos ao
barramento. Porém, as coincidências acabam aí. No cliente não
criaremos ['Servants] e nem criaremos ofertas, apenas faremos uma
busca e de posse da oferta, faremos uso desta.

Vejamos aqui novamente a autenticação, mas desta vez de nosso cliente:

[searching_offers_auth]

Como vimos, a instanciação da classe [classref openbus::assistant::Assistant]
coloca o __Assistant__ em responsabilidade por nos autenticar ao
barramento de forma assincrona. Agora, nos resta fazer uso do Registro
de Ofertas através do __Assistant__. Para fazermos uma busca no
barramento por serviços, fazemos uso da função `findServices`.

Mas, para podermos fazer a busca, precisamos saber o que
buscar. Sabemos que nosso serviço possui uma faceta chamada `hello`, e
que o mesmo se autenticou no barramento com usuário: `usuario`. Este
usuário representa a entidade deste serviço. Em posse dessas
informações, podemos usar uma função auxiliar do __Assistant__ que
constroi uma lista de propriedades com essas duas propriedades. O nome
desta função é `createFacetAndEntityProperty`. E então de posse dessa
lista de propriedades podemos fazer a busca imediatamente.

A função `findServices` de busca de serviços recebe dois parâmetros:
uma lista de propriedades, que construiremos com a função
`createFacetAndEntityProperty`; e um inteiro que representa o número
de re-tentativas que a função deve fazer em caso de erros. Esse número
pode ser `-1`, que indica que a função deve tentar indefinidamente;
pode ser o número `0`, que indica que a função deve retornar uma
exceção se qualquer falha ocorrer e nenhuma nova tentativa se a mesma
falhar; e qualquer número maior que zero, que indica o número de novas
tentativas em caso de falhas.

[searching_offers_find_service]

[note Passamos `-1` para `findServices` para que a função tente
indefinidamente até a função obter sucesso]

Obtemos o objeto `offers` contendo uma lista de ofertas que condizem com
as propriedades passadas para `findServices`.

Podemos então chamar a função `sayHello` para cada uma das ofertas recebidas.

[searching_offers_use_service]

[caution A função `findServices` possui tratamento de erros, tais como
em caso de falha de comunicação com o barramento e outros, porém, o
`for` sobre as ofertas retornadas no código acima não faz qualquer
tipo de tratamento de erros. Se alguma das operações, como `_narrow` e
`sayHello`, executadas sobre as ofertas falharem, então toda a
aplicação terminará.]

[warning O compilador Visual C++ 2005 possui um bug, aonde o
`operator[]` definido como membro de variáveis `_var` não são
prioritários e o lookup continua com o `operator[]` livre através
de uma conversão do objeto `_var` para `T*`. O erro se manifesta
como uma ambiguidade quando o argumento para `operator[]` não é
um `MICO::ULong`, geralmente o caso quando se utiliza um literal.
Para evitar esse erro de compilação é só usar o `operator*` antes
do `operator[]` da seguinte forma `(*offers)[0u]`.]

[section Tratando erros]

Toda operação remota está sujeita a falhas. Como a operação precisa
coordenar programas diferentes, rodando em arquiteturas e localidades
diferentes, inúmeras falhas são possíveis, sendo as mais comuns uma
falha de comunicação física como por exemplo o cabo de rede
desconectado. Ou o serviço pode não estar mais rodando, ou ter sido
fechado.

Portanto, é essencial que toda chamada remota esteja protegida, de
algum modo, por tratamentos de erros. Tratamento de erro em __CORBA__
é feito através de exceções. A exceção `CORBA::TRANSIENT` significa
que o serviço não conseguiu se comunicar com o outro ponto; a exceção
`CORBA::COMM_FAILURE` significa a mesma coisa, mas a conexão não
conseguiu ser iniciada por algum motivo; A exceção
`CORBA::OBJECT_NOT_EXIST` significa que o serviço que deveria prover
esse objeto __CORBA__ já não mais possui esse objeto em sua memória, e
a sua referência deve ser descartada. Outras exceções herdam de
`CORBA::SystemException`. Se fossemos tratar erros para que o programa
não termine inesperadamente, poderíamos fazer o seguinte:

[import searching_offers_errors.cpp]
[searching_offers_errors_use_service]

Esse programa exemplo retornará com sucesso se nenhuma oferta for
retornada ou se nenhuma operação remota obtiver sucesso. Se quisermos
que a aplicação tente indefinidamente até obter sucesso, como fizemos
com `findServices`, podemos mudar para o seguinte:

[import searching_offers_errors_retry.cpp]
[searching_offers_errors_retry_use_service]

[endsect]

[endsect]

[section OpenBusContext]

[classref openbus::OpenBusContext] é uma classe cuja instância
representa o contexto atual da chamada. É através dessa função que
temos acesso a várias informações do contexto atual. Como:

* a conexão atual;
* o registro atual, derivado da conexão atual ao barramento;
* informações de cadeias
* outras

Para obter uma instância dessa classe, é necessário obtê-la do ORB
através da função `resolve_initial_references`. Da seguinte maneira:

[import offers_chain.cpp]
[create_offers_get_openbus_context]

O cast `dynamic_cast` é necessário porque essa classe pode ter uma
herança virtual, que um `static_cast` não seria suficiente para
executar.

Com essa classe em mãos, podemos fazer uso de informações específicas
de contexto, como o uso de __Cadeias__.

[endsect]

[section Cadeias]

A maior evolução no barramento __Openbus__ na versão 2.0 foi a
reformulação do sistema de segurança do mesmo. Com este novo sistema
de segurança que foi desenvolvido, é possível para um serviço saber
qual entidade que fez a chamada, e também é possível para algum
serviço intermediário passar para um serviço que ele é usuário a
identidade de quem está usando esse intermediário. Isso cria uma
cadeia de entidades que pode ser lida pelo serviço final para
autorizar ou não a chamada.

Veremos o caso mais simples, modificando o serviço de ['Hello'] que
implementamos anteriormente para dizer ['Hello Usuario']. Aonde
Usuario será o nome da entidade que nos chamou. Uma aplicação mais
complexa poderia usar essa informação para escolher qual banco de
dados ele pegará os dados, ou como fará a autenticação para obter os
dados ou simplesmente recusar a operação para determinadas entidades.

Relembrando, nosso Servant foi implementado da seguinte maneira:

[create_offers_servant_hello]

O [classref openbus::OpenBusContext] oferece as seguintes funções
relativas a Cadeias: `getCallerChain`, `joinChain`, `exitChain` e
`getJoinedChain`.

Faremos uso da função `getCallerChain`. Mas para tal, precisamos ter
acesso ao __Assistant__ de dentro do nosso ['Servant]. Poderíamos usar
uma variável global, assim todo programa teria acesso ao
__Assistant__, porém como variáveis globais trazem vários problemas,
modificaremos o __Servant__ para receber como argumento de construção
o próprio __Assistant__. Assim, criaremos um construtor:

[create_offers_chain_servant_constructor]

E mudamos a instanciação do ['Servant] para passar o __Assistant__
como argumento de construção:

[create_offers_chain_instantiate_servant_hello]

E assim, já podemos fazer a chamada de `getCallerChain` em `sayHello`
usando a variável-membro `assistant` no ['Servant], para obter o
[classref openbus::OpenBusContext] e com ele fazer a chamada a
`getCallerChain`.

[create_offers_chain_say_hello]

E assim implementamos um serviço que imprime o nome da entidade que
fez a chamada remota para nosso serviço. O exemplo inteiro:

[create_offers_chain]

[endsect]

[endsect]

[/section:index Índices]

[/named_index class_name Classes]
[/named_index typedef_name Typedefs]
[/named_index function_name Funções Livres]
[/named_index macro_name Macros]
[/index]

[/endsect] 

[xinclude assistant-reference.xml]
[xinclude openbus-reference.xml]
[xinclude openbus-idl-reference.xml]


