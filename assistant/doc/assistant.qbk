[/ -*- coding: utf-8-unix  -*- ]

[library Documentação do Assistant C++
    [quickbook 1.5]
    [version 1.0]
    [id assistant]
    [copyright 2012 TecGraf/PUC-Rio]
    [authors [Almeida, Felipe Magno]]
    [/ license ]
    [source-mode c++]
]

[include auto_index_helpers.qbk]

[def __Assistant__ [link assistant Assistant]]
[def __Openbus__ Openbus]
[def __BoostParameters__ [@http://www.boost.org/doc/libs/1_51_0/libs/parameter/doc/html/index.html
Boost.Parameter] ]
[def __SharedAuthentication__ ['Shared Authentication]]
[def __MICO__ ['Mico]]
[def __CORBA__ ['CORBA]]
[def __SCS__ ['SCS]]
[def __TypeCode__ ['TypeCode]]

[section Introdução]

Esse manual oferece um overview de implementação de serviços com uso
do barramento __Openbus__, assim como explicação de várias
características opções. Os seguintes conhecimentos são assumidos pelo
documento:

* Linguagem C++
* CORBA
* Modelo de Componentes SCS

A proposta do manual é capacitar o indivíduo, que atenda aos
pré-requisitos do documento, a escrever serviços para o barramento
__Openbus__ dentro do escopo dessa API.

[endsect]

[section Instalação]

Incluir aqui quando criar o pacote

[endsect]

[section Escopo]

__Assistant__ é o nome de uma abstração da biblioteca de acesso do
__Openbus__. Ela visa facilitar os recursos mais utilizados pelos
clientes do barramento. Para atingir esse objetivo, alguns sacrifícios
foram feitos e portanto o __Assistant__ não é tão flexível quanto o
uso direto da API básica, mas atende a maioria dos casos de usos
involvendo o barramento __Openbus__.

[section Aplicações no Assistant]

As aplicações mais comuns, e as que são melhores implementadas usando
o __Assistant__ tem o seguinte em comum:

* Se comunica com um único barramento
* Possui apenas uma autenticação com o barramento

Geralmente um aplicativo que se conecta ao barramento é um de dois
tipos, ou um híbrido:

* Servidor
* Cliente

Um servidor adiciona ofertas no barramento, disponibilizando um ou
mais serviços através destas ofertas. Um cliente, pelo outro lado,
consulta o barramento por ofertas de serviços que deseja consumir.

[endsect]

[section O que o Assistant não faz]

Por ser uma abstração mais simples e focada em um grupo de casos de
uso, naturalmente o __Assistant__ não consegue resolver todos os
problemas que a API básica, da qual o __Assistant__ é implementado,
pode.

Portanto, os seguintes casos só conseguem ser implementados com uso da
API básica:

* Se comunica com mais de um barramento
* Faz uso de mais de um ORB
* Possui múltiplas identidades com um ou mais barramentos

O __Assistant__ recebe as informações de autenticação como usuário,
senha, chave privada, etc, na construção do __Assistant__, assim
como outras informações necessárias para uso de CORBA.

Com essas informações, o __Assistant__ se autentica com o barramento,
de forma assíncrona e mantém válida essa autenticação, renovando a
autenticação quando esta expira. Também é refeita a autenticação se a
mesma ficar inválida por qualquer outro motivo, como por remoção
através de ferramentas de governança do barramento __Openbus__.

[warning A construção do __Assistant__ não implica que a autenticação
já tenha ocorrido com sucesso. O que significa que funções sincronas,
como findServices podem falhar com a exceção NO_PERMISSION por não
estar ainda autenticado com o barramento __Openbus__]

[endsect]

[section Vantagens de usar o Assistant]

Para as aplicações que estão no escopo do __Assistant__, usar o __Assistant possui várias vantagens. Dentre as principais:

* Autenticação simplificada com o barramento
* Tratamento automático de erros
* Manter serviços ofertados

Como foi dito anteriormente, a autenticação ocorre de forma
assíncrona. O mesmo ocorre com o registro de ofertas. Essa diferença
entre __Assistant__ e a API básica é crucial para entender as
vantagens de se usar o __Assistant__.

O registro de oferta ocorre de forma assíncrona e se por qualquer
motivo o registro se perder, como por perder autenticação com o
barramento, o __Assistant__ automaticamente faz um novo registro de
oferta. Assim, o usuário não precisa se preocupar com os vários casos
de erros que possam acontecer num sistema distribuido para garantir
que suas ofertas estão visiveis para outros serviços.

Para funções que são sincronas, como as que se espera um retorno, como
busca por ofertas. O __Assistant__ recebe também um parâmetro de
número de tentativas, assim o usuário pode usar o tratamento de erro
automático do __Assistant__ para essas chamadas remotas, que podem
falhar por inúmeros motivos.

[endsect]

[endsect]

[section Desenvolvimento]

Prover um serviço no __Openbus__ usando o __Assistant__ é bem
simples. Para isso, precisamos construir uma instância da classe
__Assistant__ que nos proverá as funções necessárias para ofertar
serviços no barramento.

Em C++ instancia-se a classe [classref openbus::assistant::Assistant] usando,
preferencialmente, ['named parameters].

[section Named Parameters]

['Named Parameters] é uma forma de passagem de argumentos, aonde cada
argumento e parâmetro é casado no ponto de chamada. Um exemplo
hipotético de ['named parameters] seria o seguinte:

[import namedparameters.cpp]
[namedparameters]

[note No __Assistant__ todos os parâmetros começam com um
['underscore], esse é o padrão seguido pela biblioteca 
__BoostParameters__ que é usada no __Assistant__]

Os seguintes parâmetros existem no __Assistant__:

[table Named parameters existentes no Assistant
  [[Parametros] [Descrição]]
  [
        [`_host`]
[Nome do ['host] aonde se encontra o barramento. Conteúdo deste ['named parameter] é obrigatório. Pode ser passado com ['named parameter] ou como
primeiro argumento do construtor do [classref openbus::assistant::Assistant].]
  ]
  [
        [`_port`]
[Porta TCP de onde se encontra o barramento. Conteúdo deste ['named parameter] é obrigatório. Pode ser passado com ['named parameter] ou como
segundo argumento do construtor do [classref openbus::assistant::Assistant].]
  ]
  [
        [`_username`]
[Nome do usuário para autenticação ao barramento. Esse parâmetro deve ser usado quando se pretende fazer uma autenticação
por usuário e senha. Deve sempre ser usado junto com o ['named parameter] _password.]
  ]
  [
        [`_entity`]
[Nome da entidade registrada por certificado no barramento. Esse parâmetro deve ser usado quando se pretende
fazer uma autenticação por certificado. Deve sempre ser usado junto com um dos dois ['named parameters] _private_key
ou _private_key_filename.]
  ]
  [
        [`_password`]
[Senha de autenticação. Esse parâmetro deve ser usado quando se pretende fazer uma autenticação por usuário e senha.
Deve sempre ser usado junto com o ['named parameter] _username.]
  ]
  [
        [`_private_key`]
[Conteúdo de chave privada usada para criação do certificado registrado no barramento. Esse parâmetro deve ser usado quando se
pretende fazer uma autenticação por certificado. Seu tipo deve ser um CORBA::OctetSeq e seu conteúdo deve ser de uma
chave privada gerada com o ['shell script] openssl-generate.sh. Deve sempre ser usado com o ['named parameter] _entity.]
  ]
  [
        [`_private_key_filename`]
[Nome do arquivo que contém a chave privada usada para criação do certificado registrado no barramento. Esse parâmetro deve
ser usado quando se
pretende fazer uma autenticação por certificado. O conteúdo deste arquivo deve ser de uma
chave privada gerada com o ['shell script] openssl-generate.sh. Deve sempre ser usado com o ['named parameter] _entity.]
  ]
  [
        [`_shared_auth_callback`]
[['Function object] de assinatura `std::pair<LoginProcess, CORBA::OctetSeq>()`. Esse ['function object] deve
retornar um par contendo um `LoginProcess` e um segredo em `CORBA::OctetSeq` que tenham sido retornados
por um `startSharedAuth` sobre uma conexão com o mesmo barramento. Essa função pode ser chamada mais de uma vez,
e o seu retorno não deve se repetir, já que o objeto `LoginProcess` só é válido ao ser usado pela primeira vez.]
  ]
  [
        [`_retry_wait`]
[Número de segundos de espera em caso de erros. Esse argumento modifica o tempo entre tentativas de operações
com o barramento.]
  ]
  [
        [`_log_level`]
[Nível de log utilizado pela implementação do __Assistant__ em sua execução. Os níveis existentes, em ordem crescente de verbosidade, são: `::logger::disabled_level`, `::logger::error_level`, `::logger::warning_level`, `::logger::info_level` e
`::logger::debug_level`.]
  ]
  [
        [`_argc`]
[Número de argumentos no ['array] passado em _argv. Esse parâmetro é usado para passar o par argc e argv
da função `int main(int argc, char* argv[])` para o ORB. Isso permite que o usuário do aplicativo configure
algumas características do ORB por linha de comando do aplicativo. Deve ser usado em conjunto com ['named parameter] _argv.
Esse argumento pode ser modificado pelo ORB.]
  ]
  [
        [`_argv`]
[['Array] de argumentos de linha de comando. Esse parâmetro é usado para passar o par argc e argv
da função `int main(int argc, char* argv[])` para o ORB. Isso permite que o usuário do aplicativo configure
algumas características do ORB por linha de comando do aplicativo. Deve ser usado em conjunto com ['named parameter] _argc,
que indica o número de argumentos que contém o array. Esse argumento pode ser modificado pelo ORB.]
  ]
  [
        [`_on_login_error`]
[['Function object] de tratamento de erros de ['login]. O ['function object] passado como argumento deve ter a assinatura
`void(std::string)`. O argumento `std::string` passado é o nome da exceção que foi tratatada pelo __Assistant__.
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
  [
        [`_on_register_error`]
[['Function object] de tratamento de erros de registro de ofertas. O ['function object] passado como argumento deve ter
 a assinatura `void(IComponent_var, ServicePropertySeq, std::string)`. O argumento `IComponent_var` é a referência CORBA
usada para tentativa de registro; o argumento `ServicePropertySeq` é o conjunto de propriedades a serem registradas
na oferta e o argumento `std::string` passado é o nome da exceção que foi tratatada pelo __Assistant__ durante o erro.
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
  [
        [`_on_fatal_error`]
[['Function object] de tratamento de erros fatais. O ['function object] passado como argumento deve ter
 a assinatura `void(const char*)`. O argumento passado é o nome da exceção que foi tratatada pelo __Assistant__ durante o erro.
[note Essa função recebe um `const char*` ao invés de um `std::string`, pois essa função pode ser executada por motivos
de falta de recursos. Assim, o __Assistant__ evita uma alocação requerida pela classe `std::string` para evitar que
outra exceção possa ser lançada durante a tentativa de tratamento do erro.]
[note Essa função pode ser executada em outra thread em um ambiente multithread.] ]
  ]
]

Os parâmetros `_host` e `_port` são obrigatórios, e portanto é possível passar os argumentos sem referenciar os parâmetros, apenas passando-os como os primeiros argumentos na construção do __Assistant__, da seguinte forma:

[import namedparameters_host_port.cpp]
[namedparameters_host_port]

[caution Se o seu compilador não suportar __BoostParameters__, então é
possível definir a macro `OPENBUS_ASSISTANT_DISABLE_NAMED_PARAMETERS`
na compilação do projeto e usar uma das funções `createWithPassword`,
`createWithPrivateKey` ou `createWithSharedAuth` para criar o
__Assistant__]

[endsect]

[section Autenticando no barramento]

Como vimos nos parâmetros disponíveis para construção do
__Assistant__, temos disponíveis três métodos de autenticação:

* Por usuário e senha
* Por certificado, com chave privada
* Por __SharedAuthentication__

[section Autenticação por usuário e senha]

A autenticação por usuário e senha se faz com os parâmetros
`_username` e `_password`.

[import auth_user.cpp]
[auth_user]

Como vimos anteriormente, após a construção de
`openbus::assistant::Assistant`, a autenticação não necessariamente já
ocorreu, pois a mesma é feita assincronamente e pode se repetir
indefinidamente, sem intervenção do usuário. O __Assistant__ assume
que o cliente pretende se manter logado por todo o tempo em que o
__Assistant__ se mantiver vivo. E por isso em qualquer erro que
implique na perda de autenticação o __Assistant__ tratará-lo tentando
se autenticar novamente até conseguir. Esse é uma das principais
vantagens de se usar o __Assistant__.

[endsect]

[section Autenticação por chave privada]

Existem duas formas de se autenticar por chave privada no __Assistant__
do C++:

* Com o conteúdo em um OctetSeq CORBA
* Passando como argumento o nome do arquivo da chave

Nem sempre a chave se encontra em um arquivo, como por exemplo no caso
de construção de uma chave privada dinamicamente, ou recebida por
algum método de IPC. Neste caso faz mais sentido passar o conteúdo da
chave diretamente:

[import auth_private_key.cpp]
[auth_private_key]

Porém, se a chave estiver em um arquivo seria muito mais fácil passar
o nome do arquivo do que fazer a leitura do mesmo em um
OctetSeq. Neste caso é só usar o parâmetro `_private_key_filename`:

[import auth_private_key_file.cpp]
[auth_private_key_file]

[endsect]

[endsect]

[section Registrando ofertas]

O propósito principal do __Assistant__ para um servidor, é o de
autenticar ao barramento __Openbus__ e ofertar os serviços no Registro
de Ofertas.

Primeiramente fazemos o `#include` do ['header] do __Assistant__ para
que possamos construir um `openbus::assistant::Assistant`.

[import offers.cpp]
[create_offers_include]

Feito isto, podemos instanciar a classe
`openbus::assistant::Assistant`, que cuidará da autenticação por nós:

[create_offers_auth]

Se formos ofertar algum serviço, esse serviço precisa estar definido
em alguma IDL. Usaremos como base a seguinte IDL, que não poderia ser
mais simples:

[import hello.idl]
[say_hello_idl]

Dada esta IDL, precisamos fazer o `#include` do ['header] do ['stub]
gerado pelo __MICO__ e fazer a implementação de seu ['Servant].

[create_offers_include_hello]

[note Estamos usando como padrão neste documento que os ['stubs]
gerados pelo compilador IDL do __MICO__ se encontrem em um diretório
chamado ['stubs], porém, essa é apenas um padrão de uso e para
projetos mais simples não é necessário e nem sempre vantajoso separar
este header de outros, dependendo de qual sistema de ['build] se está
usando]

E então a construção do ['Servant] __CORBA__:

[create_offers_servant_hello]

Definido o ['Servant], fazemos sua instanciação para inclusão em um
componente __SCS__,que será finalmente ofertado no barramento:

[create_offers_instantiate_servant_hello]

[note Por não haver necessidade de alocação dinâmica, instanciamos o
['Servant] na ['automatic storage], aonde o objeto será desalocado
automaticamente no fim de seu escopo. Facilitando o raciocínio sobre o
software, assim como elimina uma possibilidade de memory leak]

Instanciado o ['Servant], podemos incluir este como faceta do
componente que será ofertado, mas para isto primeiro o componente
precisa ser também instanciado:

[create_offers_instantiate_component]

E então a faceta adicionada:

[create_offers_add_facet]

[note Usamos aqui o objeto de __TypeCode__ para retornar o ['RepoID]
da nossa interface `Hello`. Assim diminuimos uma redundância e
adicionamos uma checagem estática se o nome da classe mudar. Porém, é
necessário lembrar de passar o parâmetro `--typecode` para o
compilador IDL do __MICO__]

Vejamos nosso pequeno servidor como fica ao criar o componente com
nossa faceta:

[create_offers_component_created]

Agora só nos resta registrar o serviço e passar a linha de execução
para o __ORB__. Registrando o serviço:

[create_offers_register_service]

E chamando `run()` no __ORB__:

[create_offers_run]

E assim terminamos a construção de nosso pequeno serviço ofertado no
barramento:

[create_offers]

[endsect]

[section Buscando ofertas no barramento]

[import searching_offers.cpp]

Já criamos o servidor, agora para completar é necessário construir um
consumidor deste serviço. Alguém que irá buscar esse serviço no
Registro de Ofertas e chamar `sayHello()`, que é o que nosso serviço
atualmente faz.

Para tal, precisamos, assim como no servidor, autenticar-nos ao
barramento. Porém, as coincidências acabam aí. No cliente não
criaremos ['Servants] e nem criaremos ofertas, apenas faremos uma
busca e de posse da oferta, faremos uso desta.

Vejamos aqui novamente a autenticação, mas desta vez de nosso cliente:

[searching_offers_auth]

Como vimos, a instanciação da classe `openbus::assistant::Assistant`
coloca o __Assistant__ em responsabilidade por nos autenticar ao
barramento de forma assincrona. Agora, nos resta fazer uso do Registro
de Ofertas através do __Assistant__. Para fazermos uma busca no
barramento por serviços, fazemos uso da função `findServices`.

Mas, para podermos fazer a busca, precisamos saber o que
buscar. Sabemos que nosso serviço possui uma faceta chamada `hello`, e
que o mesmo se autenticou no barramento com usuário: `usuario`. Este
usuário representa a entidade deste serviço. Em posse dessas
informações, podemos usar uma função auxiliar do __Assistant__ que
constroi uma lista de propriedades com essas duas propriedades. O nome
desta função é `createFacetAndEntityProperty`. E então de posse dessa
lista de propriedades podemos fazer a busca imediatamente.

A função `findServices` de busca de serviços recebe dois parâmetros:
uma lista de propriedades, que construiremos com a função
`createFacetAndEntityProperty`; e um inteiro que representa o número
de re-tentativas que a função deve fazer em caso de erros. Esse número
pode ser `-1`, que indica que a função deve tentar indefinidamente;
pode ser o número `0`, que indica que a função deve retornar uma
exceção se qualquer falha ocorrer e nenhuma nova tentativa se a mesma
falhar; e qualquer número maior que zero, que indica o número de novas
tentativas em caso de falhas.

[searching_offers_find_service]

[note Passamos `-1` para `findServices` para que a função tente
indefinidamente até a função obter sucesso]

Obtemos o objeto `offers` contendo uma lista de ofertas que condizem com
as propriedades passadas para `findServices`.

Podemos então chamar a função `sayHello` para cada uma das ofertas recebidas.

[searching_offers_use_service]

[caution A função `findServices` possui tratamento de erros, tais como
em caso de falha de comunicação com o barramento e outros, porém, o
`for` sobre as ofertas retornadas no código acima não faz qualquer
tipo de tratamento de erros. Se alguma das operações, como `_narrow` e
`sayHello`, executadas sobre as ofertas falharem, então toda a
aplicação terminará.]

[section Tratando erros]

Toda operação remota está sujeita a falhas. Como a operação precisa
coordenar programas diferentes, rodando em arquiteturas e localidades
diferentes, inúmeras falhas são possíveis, sendo as mais comuns uma
falha de comunicação física como por exemplo o cabo de rede
desconectado. Ou o serviço pode não estar mais rodando, ou ter sido
fechado.

Portanto, é essencial que toda chamada remota esteja protegida, de
algum modo, por tratamentos de erros. Tratamento de erro em __CORBA__
é feito através de exceções. A exceção `CORBA::TRANSIENT` significa
que o serviço não conseguiu se comunicar com o outro ponto; a exceção
`CORBA::COMM_FAILURE` significa a mesma coisa, mas a conexão não
conseguiu ser iniciada por algum motivo; A exceção
`CORBA::OBJECT_NOT_EXIST` significa que o serviço que deveria prover
esse objeto __CORBA__ já não mais possui esse objeto em sua memória, e
a sua referência deve ser descartada. Outras exceções herdam de
`CORBA::SystemException`. Se fossemos tratar erros para que o programa
não termine inesperadamente, poderíamos fazer o seguinte:

[import searching_offers_errors.cpp]
[searching_offers_errors_use_service]

Esse programa exemplo retornará com sucesso se nenhuma oferta for
retornada ou se nenhuma operação remota obtiver sucesso. Se quisermos
que a aplicação tente indefinidamente até obter sucesso, como fizemos
com `findServices`, podemos mudar para o seguinte:

[import searching_offers_errors_retry.cpp]
[searching_offers_errors_retry_use_service]

[endsect]

[endsect]

[section Cadeias]

A maior evolução no barramento __Openbus__ na versão 2.0 foi a
reformulação do sistema de segurança do mesmo. Com este novo sistema
de segurança que foi desenvolvido, é possível para um serviço saber
qual entidade que fez a chamada, e também é possível para algum
serviço intermediário passar para um serviço que ele é usuário a
identidade de quem está usando esse intermediário. Isso cria uma
cadeia de entidades que pode ser lida pelo serviço final para
autorizar ou não a chamada.

Veremos o caso mais simples, modificando o serviço de ['Hello'] que
implementamos anteriormente para dizer ['Hello Usuario']. Aonde
Usuario será o nome da entidade que nos chamou. Uma aplicação mais
complexa poderia usar essa informação para escolher qual banco de
dados ele pegará os dados, ou como fará a autenticação para obter os
dados ou simplesmente recusar a operação para determinadas entidades.

Relembrando, nosso Servant foi implementado da seguinte maneira:

[create_offers_servant_hello]

O __Assistant__ oferece as seguintes funções relativas a Cadeias:
`getCallerChain`, `joinChain`, `exitChain` e `getJoinedChain`.

Faremos uso da função `getCallerChain`. Mas para tal, precisamos ter
acesso ao __Assistant__ de dentro do nosso ['Servant]. Poderíamos usar
uma variável global, assim todo programa teria acesso ao
__Assistant__, porém como variáveis globais trazem vários problemas,
modificaremos o __Servant__ para receber como argumento de construção
o próprio __Assistant__. Assim, criaremos um construtor:

[import offers_chain.cpp]
[create_offers_chain_servant_constructor]

E mudamos a instanciação do ['Servant] para passar o __Assistant__
como argumento de construção:

[create_offers_chain_instantiate_servant_hello]

E assim, já podemos fazer a chamada de `getCallerChain` em `sayHello`
usando a variável-membro `assistant` no ['Servant].

[create_offers_chain_say_hello]

E assim implementamos um serviço que imprime o nome da entidade que
fez a chamada remota para nosso serviço. O exemplo inteiro:

[create_offers_chain]

[endsect]

[endsect]

[section:index Índices]

[named_index class_name Classes]
[named_index typedef_name Typedefs]
[named_index function_name Funções Livres]
[named_index macro_name Macros]
[/index]

[endsect] 

[xinclude reference.xml]

