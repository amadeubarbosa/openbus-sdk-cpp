[/ -*- coding: utf-8-unix  -*- ]

[library Documentação do Assistant C++
    [quickbook 1.5]
    [version 1.0]
    [id assistant]
    [copyright 2012 TecGraf/PUC-Rio]
    [authors [Almeida, Felipe Magno]]
    [/ license ]
    [source-mode c++]
]

[def __Assistant__ [link assistant Assistant]]
[def __Openbus__ Openbus]

[section Introdução]

Esse manual oferece um overview de implementação de serviços com uso
do barramento __Openbus__, assim como explicação de várias
características opções. Os seguintes conhecimentos são assumidos pelo
documento:

* Linguagem C++
* CORBA
* Modelo de Componentes SCS

A proposta do manual é capacitar o indivíduo, que atenda aos
pré-requisitos do documento, a escrever serviços para o barramento
__Openbus__ dentro do escopo dessa API.

[endsect]

[section Instalação]

Incluir aqui quando criar o pacote

[endsect]

[section Escopo]

__Assistant__ é o nome de uma abstração da biblioteca de acesso do
__Openbus__. Ela visa facilitar os recursos mais utilizados pelos
clientes do barramento. Para atingir esse objetivo, alguns sacrifícios
foram feitos e portanto o __Assistant__ não é tão flexível quanto o
uso direto da API básica, mas atende a maioria dos casos de usos
involvendo o barramento __Openbus__.

[section Aplicações no Assistant]

As aplicações mais comuns, e as que são melhores implementadas usando
o __Assistant__ tem o seguinte em comum:

* Se comunica com um único barramento
* Possui apenas uma autenticação com o barramento

Geralmente um aplicativo que se conecta ao barramento é um de dois
tipos, ou um híbrido:

* Servidor
* Cliente

Um servidor adiciona ofertas no barramento, disponibilizando um ou
mais serviços através destas ofertas. Um cliente, pelo outro lado,
consulta o barramento por ofertas de serviços que deseja consumir.

[endsect]

[section O que o Assistant não faz]

Por ser uma abstração mais simples e focada em um grupo de casos de
uso, naturalmente o __Assistant__ não consegue resolver todos os
problemas que a API básica, da qual o __Assistant__ é implementado,
pode.

Portanto, os seguintes casos só conseguem ser implementados com uso da
API básica:

* Se comunica com mais de um barramento
* Faz uso de mais de um ORB
* Possui múltiplas identidades com um ou mais barramentos

O __Assistant__ recebe as informações de autenticação como usuário,
senha, chave privada, etc, na construção do __Assistant__, assim
como outras informações necessárias para uso de CORBA.

Com essas informações, o __Assistant__ se autentica com o barramento,
de forma assíncrona e mantém válida essa autenticação, renovando a
autenticação quando esta expira. Também é refeita a autenticação se a
mesma ficar inválida por qualquer outro motivo, como por remoção
através de ferramentas de governança do barramento __Openbus__.

[warning A construção do __Assistant__ não implica que a autenticação
já tenha ocorrido com sucesso. O que significa que funções sincronas,
como findServices podem falhar com a exceção NO_PERMISSION por não
estar ainda autenticado com o barramento __Openbus__]

[endsect]

[section Vantagens de usar o Assistant]

Para as aplicações que estão no escopo do __Assistant__, usar o __Assistant possui várias vantagens. Dentre as principais:

* Autenticação simplificada com o barramento
* Tratamento automático de erros



[endsect]

[endsect]

[section Desenvolvimento]

Prover um serviço no __Openbus__ usando o __Assistant__ é bem
simples. Para isso, precisamos construir uma instância da classe
__Assistant__ que nos proverá as funções necessárias para ofertar
serviços no barramento.

Em C++ instancia-se a classe openbus::assistant::Assistant usando,
preferencialmente, ['named parameters].

[section Named Parameters]

['Named Parameters] é uma forma de passagem de argumentos, aonde cada
argumento e parâmetro é casado no ponto de chamada. Um exemplo
hipotético de ['named parameters'] seria o seguinte:

           int main()
           {
           }

[endsect]

[section Autenticando no barramento]


[endsect]

[endsect]
