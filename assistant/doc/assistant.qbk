[/ -*- coding: utf-8-unix  -*- ]

[library Documentação do Assistant C++
    [quickbook 1.5]
    [version 1.0]
    [id assistant]
    [copyright 2012 TecGraf/PUC-Rio]
    [authors [Almeida, Felipe Magno]]
    [/ license ]
    [source-mode c++]
]

[def __Assistant__ [link assistant Assistant]]
[def __Openbus__ Openbus]
[def __BoostParameters__ [@http://www.boost.org/doc/libs/1_51_0/libs/parameter/doc/html/index.html
Boost.Parameter] ]

[section Introdução]

Esse manual oferece um overview de implementação de serviços com uso
do barramento __Openbus__, assim como explicação de várias
características opções. Os seguintes conhecimentos são assumidos pelo
documento:

* Linguagem C++
* CORBA
* Modelo de Componentes SCS

A proposta do manual é capacitar o indivíduo, que atenda aos
pré-requisitos do documento, a escrever serviços para o barramento
__Openbus__ dentro do escopo dessa API.

[endsect]

[section Instalação]

Incluir aqui quando criar o pacote

[endsect]

[section Escopo]

__Assistant__ é o nome de uma abstração da biblioteca de acesso do
__Openbus__. Ela visa facilitar os recursos mais utilizados pelos
clientes do barramento. Para atingir esse objetivo, alguns sacrifícios
foram feitos e portanto o __Assistant__ não é tão flexível quanto o
uso direto da API básica, mas atende a maioria dos casos de usos
involvendo o barramento __Openbus__.

[section Aplicações no Assistant]

As aplicações mais comuns, e as que são melhores implementadas usando
o __Assistant__ tem o seguinte em comum:

* Se comunica com um único barramento
* Possui apenas uma autenticação com o barramento

Geralmente um aplicativo que se conecta ao barramento é um de dois
tipos, ou um híbrido:

* Servidor
* Cliente

Um servidor adiciona ofertas no barramento, disponibilizando um ou
mais serviços através destas ofertas. Um cliente, pelo outro lado,
consulta o barramento por ofertas de serviços que deseja consumir.

[endsect]

[section O que o Assistant não faz]

Por ser uma abstração mais simples e focada em um grupo de casos de
uso, naturalmente o __Assistant__ não consegue resolver todos os
problemas que a API básica, da qual o __Assistant__ é implementado,
pode.

Portanto, os seguintes casos só conseguem ser implementados com uso da
API básica:

* Se comunica com mais de um barramento
* Faz uso de mais de um ORB
* Possui múltiplas identidades com um ou mais barramentos

O __Assistant__ recebe as informações de autenticação como usuário,
senha, chave privada, etc, na construção do __Assistant__, assim
como outras informações necessárias para uso de CORBA.

Com essas informações, o __Assistant__ se autentica com o barramento,
de forma assíncrona e mantém válida essa autenticação, renovando a
autenticação quando esta expira. Também é refeita a autenticação se a
mesma ficar inválida por qualquer outro motivo, como por remoção
através de ferramentas de governança do barramento __Openbus__.

[warning A construção do __Assistant__ não implica que a autenticação
já tenha ocorrido com sucesso. O que significa que funções sincronas,
como findServices podem falhar com a exceção NO_PERMISSION por não
estar ainda autenticado com o barramento __Openbus__]

[endsect]

[section Vantagens de usar o Assistant]

Para as aplicações que estão no escopo do __Assistant__, usar o __Assistant possui várias vantagens. Dentre as principais:

* Autenticação simplificada com o barramento
* Tratamento automático de erros
* Manter serviços ofertados

Como foi dito anteriormente, a autenticação ocorre de forma
assíncrona. O mesmo ocorre com o registro de ofertas. Essa diferença
entre __Assistant__ e a API básica é crucial para entender as
vantagens de se usar o __Assistant__.

O registro de oferta ocorre de forma assíncrona e se por qualquer
motivo o registro se perder, como por perder autenticação com o
barramento, o __Assistant__ automaticamente faz um novo registro de
oferta. Assim, o usuário não precisa se preocupar com os vários casos
de erros que possam acontecer num sistema distribuido para garantir
que suas ofertas estão visiveis para outros serviços.

Para funções que são sincronas, como as que se espera um retorno, como
busca por ofertas. O __Assistant__ recebe também um parâmetro de
número de tentativas, assim o usuário pode usar o tratamento de erro
automático do __Assistant__ para essas chamadas remotas, que podem
falhar por inúmeros motivos.

[endsect]

[endsect]

[section Desenvolvimento]

Prover um serviço no __Openbus__ usando o __Assistant__ é bem
simples. Para isso, precisamos construir uma instância da classe
__Assistant__ que nos proverá as funções necessárias para ofertar
serviços no barramento.

Em C++ instancia-se a classe openbus::assistant::Assistant usando,
preferencialmente, ['named parameters].

[section Named Parameters]

['Named Parameters] é uma forma de passagem de argumentos, aonde cada
argumento e parâmetro é casado no ponto de chamada. Um exemplo
hipotético de ['named parameters] seria o seguinte:

[import namedparameters.cpp]
[namedparameters]

[note No __Assistant__ todos os parâmetros começam com um
['underscore], esse é o padrão seguido pela biblioteca 
__BoostParameters__ que é usada no __Assistant__]

Os seguintes parâmetros existem no __Assistant__:

[table Named parameters existentes no Assistant
  [[Parametros] [Descrição]]
  [
        [_host]
        [asd]
  ]
  [
        [_port]
        [asd]
  ]
  [
        [_username]
        [asd]
  ]
  [
        [_entity]
        [asd]
  ]
  [
        [_password]
        [asd]
  ]
  [
        [_private_key]
        [asd]
  ]
  [
        [_private_key_filename]
        [asd]
  ]
  [
        [_shared_auth_callback]
        [asd]
  ]
  [
        [_argc]
        [asd]
  ]
  [
        [_argv]
        [asd]
  ]
  [
        [_on_login_error]
        [asd]
  ]
  [
        [_on_register_error]
        [asd]
  ]
  [
        [_on_fatal_error]
        [asd]
  ]
  [
        [_retry_wait]
        [asd]
  ]
  [
        [_log_level]
        [asd]
  ]
]

Os parâmetros `_host` e `_port` são obrigatórios, e portanto é possível passar os argumentos sem referenciar os parâmetros, apenas passando-os como os primeiros argumentos na construção do __Assistant__, da seguinte forma:

[import namedparameters_host_port.cpp]
[namedparameters_host_port]

[caution Se o seu compilador não suportar __BoostParameters__, então é
possível definir a macro `OPENBUS_ASSISTANT_DISABLE_NAMED_PARAMETERS`
na compilação do projeto e usar uma das funções `createWithPassword`,
`createWithPrivateKey` ou `createWithSharedAuth` para criar o
__Assistant__]

[endsect]

[section Autenticando no barramento]

Como vimos nos parâmetros disponíveis para construção do
__Assistant__, temos disponíveis três métodos de autenticação:

* Por usuário e senha
* Por certificado, com chave privada
* Por ['Shared Authentication]

[section Autenticação por usuário e senha]

A autenticação por usuário e senha se faz com os parâmetros
`_username` e `_password`.

[import auth_user.cpp]
[auth_user]

Como vimos anteriormente, após a construção de
`openbus::assistant::Assistant`, a autenticação não necessariamente já
ocorreu, pois a mesma é feita assincronamente e pode se repetir
indefinidamente, sem intervenção do usuário. O __Assistant__ assume
que o cliente pretende se manter logado por todo o tempo em que o
__Assistant__ se mantiver vivo. E por isso em qualquer erro que
implique na perda de autenticação o __Assistant__ tratará-lo tentando
se autenticar novamente até conseguir. Esse é uma das principais
vantagens de se usar o __Assistant__.

[endsect]

[section Autenticação por chave privada]

Existem duas formas de se autenticar por chave privada no __Assistant__
do C++:

* Com o conteúdo em um OctetSeq CORBA
* Passando como argumento o nome do arquivo da chave

Nem sempre a chave se encontra em um arquivo, como por exemplo no caso
de construção de uma chave privada dinamicamente, ou recebida por
algum método de IPC. Neste caso faz mais sentido passar o conteúdo da
chave diretamente:

[import auth_private_key.cpp]
[auth_private_key]


[endsect]

[endsect]
