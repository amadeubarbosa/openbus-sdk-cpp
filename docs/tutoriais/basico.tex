\documentclass[a4paper, 11pt]{article}
\usepackage{a4}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{hyperref}

\lstset{
  language = c++, 
  breaklines = true,
  breakatwhitespace = true,
  showlines = true
}

\title{Tutorial Openbus C++ 1.5.1}
\author{R. Cosme \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{\today}


\begin{document}
\maketitle

\section{Introdução}
Este documento tem por objetivo servir como ponto de partida para os usuários desenvolvedores de aplicações C++ que estão interessados em programar utilizando o Openbus. O processo de \emph{deployment} do barramento não é coberto aqui neste tutorial. Considera-se como pré-requisitos para um bom entendimento deste texto um conhecimento básico dos seguintes assuntos:

\begin{itemize}
  \item Linguagem de programação C++.
  \item CORBA.
  \item Modelo de Componentes SCS.
  \item Conceitos básicos do Openbus.
\end{itemize}

Maiores informações podem ser obtidas em:
http://www.tecgraf.puc-rio.br/openbus

\section{Preparação do Ambiente}
O Openbus C++ suporta os ORB`s Mico 2.3.13 e Orbix 6.3 Service Pack 3. O usuário Mico pode escolher entre 
a versão singlethread ou multithread. Abaixo explicamos o que deveria ser feito na configuração 
destes ORB`s para que o usuário possa utilizar o Openbus. Assumimos que o usuário tenha adquirido 
o ORB através de um pacote Openbus SDK C++ obtido em nosso site.

\subsection {Mico 2.3.13} 

Para que se possa utilizar o Mico, deveria somente ser necessário carregar no shell do usuário 
o arquivo de configuração \lstinline!mico-setup.sh!, para usuários que usam *bash* ou \lstinline!mico-setup.csh! para usuários que usam *csh*. Este script pode ser encontrado no diretório \lstinline!specs/shell! da instalação do pacote. O usuário que já tem o Mico instalado, deve verificar se este arquivo está sendo carregado no seu ambiente. Este script fica localizado 
na pasta \lstinline!lib! da instalação do Mico. Atenção, não recomendamos a utilização de um Mico 
que não aquele fornecido em nosso pacote. Mantemos algumas alterações proprietárias do Mico que são necessárias para o correto funcionamento de todas as funcionalidades ofertadas pela API Openbus C++.
 
\subsection {Orbix 6.3 sp3}
No Orbix o usuário precisa habilitar o mecanismo de interceptação de CORBA, pois o mesmo não está habilitado 
por padrão. O Openbus utiliza este recurso no processo de controle de acesso aos serviços. O usuário também precisa carregar um script de configuração do ambiente no seu shell.
 
Este ORB é configurável através de domínios de configuração que por sua vez 
formam um ambiente. O domínio é formado por escopos que são representados através 
de um arquivo textual que pode ser editado diretamente pelo administrador. 
Não vamos abordar aqui como criar um domínio, para tal o usuário deve consultar a documentação 
do Orbix.

Considerando-se que o usuário tenha o seu domínio, as seguintes linhas abaixo devem ser adicionadas no arquivo de configuração do domínio:

\lstset{language=bash}
\begin{lstlisting}
tecgraf {
  openbus {
    policies:giop:interop_policy:ignore_message_not_consumed = "true";
    orb_plugins = [
      "local_log_stream", 
      "iiop_profile", 
      "giop", 
      "iiop", 
      "portable_interceptor"
    ];
    binding:server_binding_list = [
      "OTS+AccessControl", 
      "AccessControl", 
      "OTS", 
      ""
    ];
    binding:client_binding_list = [
      "AccessControl+OTS+POA_Coloc", 
      "AccessControl+POA_Coloc", 
      "OTS+POA_Coloc", 
      "POA_Coloc", 
      "AccessControl+OTS+GIOP+IIOP", 
      "AccessControl+GIOP+IIOP", 
      "OTS+GIOP+IIOP", 
      "GIOP+IIOP"
    ];
  };
};
\end{lstlisting}

As quatro diretivas necessárias para o correto funcionamento do Openbus são 
definidas no escopo \lstinline!tecgraf.openbus!. A primeira define uma política necessária para que IIOP.NET possa se comunicar com o Openbus Orbix. A segunda carrega 
o plugin responsável pelo mecanismo de interceptação. As duas últimas registram 
o interceptador (\lstinline!AccessControl!).
  
Por último, o usuário deve se certificar que o script shell que configura o domínio a ser 
utilizado foi carregado. Este arquivo é gerado como resultado do processo de configuração.

\section{Testando o ambiente}
Antes de se começar a programação, é aconselhável que o usuário coloque em 
funcionamento  a \emph{demo} Hello que acompanha o pacote. O pacote inclui a demo já 
compilada para uma plataforma em específico. O correto funcionamento 
da \emph{demo} elimina possíveis problemas que o desenvolvedor possa 
enfrentar durante o seu projeto, como por exemplo: falhas de comunicação 
com o barramento, mecanismo de interceptação não habilitado e ausência de 
bibliotecas dinâmicas externas.
Naturalmente a execução da \emph{demo} necessita de um barramento em operação. 
A \emph{demo} pode ser executada seguindo os seguintes passos:

\begin{enumerate}
  \item Definir a variável de ambiente \lstinline!OPENBUS_HOME! como o caminho absoluto da instalação 
  do pacote Openbus SDK C++.
  \item Definir a variável de ambiente \lstinline!TEC_UNAME! com o identificador da plataforma, que é a 
  última sequência de caracteres após o último hífen do nome do pacote, por exemplo: Linux26, 
  SunOS510 ou Linux26g4.
  \item Disponibilizar na variável de ambiente  \lstinline!LD_LIBRARY_PATH! o caminho 
   \lstinline!$OPENBUS_HOME/libpath/$TEC_UNAME!.
  \item Entrar no diretório \lstinline!demo/hello/orbix! ou \lstinline!demo/hello/mico!, que 
  está disponível na árvore do pacote. 
  \item Gerar uma chave privada e um certificado digital. Os arquivos devem ser disponibilizados no 
   diretório da demo. O arquivo referente ao certificado deve ser colocado
   na pasta \lstinline!certificates! do barramento, e o certificado referente ao serviço de acesso 
   deve   ser obtido junto ao administrador do barramento e
   colocado na pasta atual, em conjunto  da chave privada que foi gerada.
   \href{https://jira.tecgraf.puc-rio.br/confluence/display/ESDPUB/Geracao+de+Chaves+e+Certificados+Digitais} {Geracao de Chaves e Certificados Digitais}
  \item Editar o arquivo \lstinline!democonfig! e configurar a localização do barramento como também o nome 
  da chave privada e do certificado do serviço de controle de acesso.
  \item Executar o processo servidor: \lstinline!./runserver!

  A mensagem "Servico IHello registrado." deve ser retornada.
  \item Executar o processo cliente: \lstinline!./runclient!

  Após a execução do cliente, no terminal do processo servidor a seguinte 
  mensagem deve ser retornada: "Servant diz: HELLO!".
\end{enumerate}

Aconselha-se que o primeiro teste seja feito com o processo servidor e 
cliente na mesma máquina. O arquivo democonfig apresenta por padrão as 
configurações para este tipo de teste.
É interessante que este teste também seja realizado, se possível, utilizando-se
as máquinas finais que serão utilizadas no projeto do desenvolvedor. Problemas
de comunicação podem ocorrer por conta das configurações de rede das máquinas 
envolvidas. 

\section{Desenvolvimento}
\subsection{Compilação}
As demos disponibilizadas no pacote possuem um arquivo Makefile (GNU) para compilação.
Este arquivo pode e deve ser utilizado como ponto de partida para as modificações 
necessárias a serem realizadas no processo de compilação do projeto do usuário. 
Neste quesito existem algumas particularidades entre o uso Orbix e Mico.
\subsubsection{Mico}
O projeto do usuário deve utilizar as seguintes bibliotecas:
\begin{description}
    \item[openbusmico] Biblioteca Openbus para Mico.
    \item[scsmico] Biblioteca SCS para Mico.
    \item[logger] Biblioteca de logging.
\end{description}
As bibliotecas acima requerem: \lstinline!dl, crypto, ssl, lua5.1 e pthread! (no caso de uso 
de uma versão multithread).
O Openbus SDK C++ Mico permite a escolha entre uso singlethread ou multithread, 
como também 32 ou 64bits. Estas duas configurações podem ser definidas através 
das macros \lstinline!MULTITHREAD! e \lstinline!MICO_64!.
\subsubsection{Orbix}
O projeto deve ser compilado utilizando as seguintes bibliotecas:
\begin{description}
    \item[openbusorbix] Biblioteca Openbus para Orbix.
    \item[scsorbix] Biblioteca SCS para Mico.
    \item[logger] Biblioteca de logging.
\end{description}
As bibliotecas acima requerem: \lstinline!it_poa, it_art, it_ifc, it_portable_interceptor, dl, crypto ssl e lua5.1!.
É necessário que o usuário defina as seguintes macros: \lstinline!SCS_ORBIX! e \lstinline!OPENBUS_ORBIX!.
Estas macros são necessárias para habilitar o código referente ao uso com Orbix, pois por padrão 
o Openbus SDK C++ espera o uso do Mico.
\subsection{API}
\lstset{language=c++}
A API C++ do Openbus é representada pelo arquivo \lstinline!openbus.h! e pelo 
stub do serviço de registro, que no caso do Mico é o arquivo 
\lstinline!stubs/mico/registry_service.h! e no Orbix o arquivo 
\lstinline!stubs/orbix/registry_service.hh!. A documentação da API também está 
presente na forma de comentários nos arquivos citados acima.

\subsubsection{openbus.h}

\begin{lstlisting}
  static Openbus::getInstance()
\end{lstlisting}

Fornece a única instância do barramento.

\begin{lstlisting}
  void Openbus::init(
  int argc,
  char** argv)
\end{lstlisting}

Inicializa uma referência a um barramento.

Um ORB e um POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Os argumentos Openbus de linha de comando (argc e argv) são tratados.
Parâmetros de linha de comando: 
\begin{description}
  \item[-OpenbusHost]  Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-OpenbusDebug]
    ALL - Ativa todos os níveis de verbose.
    ERROR - Ativa o nível ERROR do debug.
    INFO - Ativa o nível INFO do debug.
    WARNING - Ativa o nível WARNING do debug.
  \item[-OpenbusDebugFile] Caminho completo ou relativo do arquivo que armazenará as  mensagens 
    de verbose. Se este parâmetro não for definido, a saída do verbose será a saída padrão.
    OBS.:  Se for  definido, o  verbose  somente  será armazenado  no  arquivo  em questão, 
    ou seja, a saída padrão não será mais utilizada.
  \item[-OpenbusValidationPolicy] Define uma política de validação das credenciais. Por padrão, 
    a política ALWAYS é adotada.
    NONE: Não há validação de credenciais.
    ALWAYS: Sempre valida cada credencial no ACS.
    CACHED: Primeiro  tenta  validar  a   credencial    consultando    um    cache   local, 
      se não conseguir, a validação  transcorre normalmente através de  uma  chamada remota 
      ao ACS.
  \item[-OpenbusValidationTime] Define o intervalo de tempo(em milisegundos)   de  validação do 
    cache de credenciais. O tempo padrão é de 30000ms.
  \item[-OpenbusFTConfigFilename] Caminho completo  ou  relativo  do  arquivo  que  descreve as 
    réplicas a serem utilizadas pelo mecanismo de tolerância a falhas.
  \item[-OpenbusTimeRenewing] Tempo em segundos de renovação da credencial.
  \end{description}

\begin{lstlisting}
  void Openbus::init(
    int argc,
    char** argv,
    char* host,
    unsigned short port)
\end{lstlisting}


Inicializa uma referência a um barramento.

Um ORB e um POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Os argumentos Openbus de linha de comando (argc e argv) são tratados.
Parâmetros de linha de comando: 
\begin{description}
  \item[-OpenbusHost]  Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-OpenbusDebug]
    ALL - Ativa todos os níveis de verbose.
    ERROR - Ativa o nível ERROR do debug.
    INFO - Ativa o nível INFO do debug.
    WARNING - Ativa o nível WARNING do debug.
  \item[-OpenbusDebugFile] Caminho completo ou relativo do arquivo que armazenará as  mensagens 
    de verbose. Se este parâmetro não for definido, a saída do verbose será a saída padrão.
    OBS.:  Se for  definido, o  verbose  somente  será armazenado  no  arquivo  em questão, 
    ou seja, a saída padrão não será mais utilizada.
  \item[-OpenbusValidationPolicy] Define uma política de validação das credenciais. Por padrão, 
    a política ALWAYS é adotada.
    NONE: Não há validação de credenciais.
    ALWAYS: Sempre valida cada credencial no ACS.
    CACHED: Primeiro  tenta  validar  a   credencial    consultando    um    cache   local, 
      se não conseguir, a validação  transcorre normalmente através de  uma  chamada remota 
      ao ACS.
  \item[-OpenbusValidationTime] Define o intervalo de tempo(em milisegundos)   de  validação do 
    cache de credenciais. O tempo padrão é de 30000ms.
  \item[-OpenbusFTConfigFilename] Caminho completo  ou  relativo  do  arquivo  que  descreve as 
    réplicas a serem utilizadas pelo mecanismo de tolerância a falhas.
  \item[-OpenbusTimeRenewing] Tempo em segundos de renovação da credencial.
\end{description}

\begin{lstlisting}
  bool Openbus::isConnected()
\end{lstlisting}

Informa o estado de conexão com o barramento.

\begin{lstlisting}
  static void Openbus::terminationHandlerCallback(long signalType)
\end{lstlisting}

Disponibiliza um \lstinline!termination handler! que desconecta o usuário do barramento e finaliza a 
execução do Openbus::run().

Essa callback pode ser utlizada em uma implementação de um \lstinline!termination handler! 
a ser escrito pelo usuário. No caso do Orbix, o método pode ser registrado diretamente na   
classe \lstinline!IT_TerminationHandler()!, e.g.:

\lstinline!IT_TerminationHandler termination_handler(openbus::Openbus::terminationHandlerCallback)!

O método desconecta o usuário do barramento,   se   este   estiver  conectado,  executa um
\lstinline!Openbus::stop()!  seguido  por  um  \lstinline!Openbus::finish()!,  e,  por  último  faz   delete  da instanciação do Openbus.

\begin{lstlisting}
  CORBA::ORB* Openbus::getORB()
\end{lstlisting}

Retorna o ORB utilizado.

\begin{lstlisting}
  PortableServer::POA* getRootPOA();
\end{lstlisting}

Retorna o RootPOA.

\begin{lstlisting}
  scs::core::ComponentBuilder* Openbus::getComponentBuilder()
\end{lstlisting}

Retorna a fábrica de componentes.

\begin{lstlisting}
  Credential_var Openbus::getInterceptedCredential()
\end{lstlisting}

Retorna a credencial interceptada pelo interceptador servidor. 
!Atenção! Esta operação somente deve ser chamada durante o processo de 
tratamento de requisição do serviço implementado.  

\begin{lstlisting}
  openbusidl::acs::IAccessControlService* Openbus::getAccessControlService()
\end{lstlisting}

Retorna o serviço de acesso.

\begin{lstlisting}
  registry_service::IRegistryService* getRegistryService(); 
\end{lstlisting}

Retorna o serviço de registro.

\begin{lstlisting}
  access_control_service::Credential* Openbus::getCredential()
\end{lstlisting}

Retorna a credencial de identificação do usuário frente ao barramento.

\begin{lstlisting}
  interceptors::CredentialValidationPolicy getCredentialValidationPolicy()
\end{lstlisting}

Retorna a política de validação de credenciais.

\begin{lstlisting}
  void setThreadCredential(access_control_service::Credential* credential)
\end{lstlisting}

Define uma credencial a ser utilizada no lugar da credencial corrente.
Útil para fornecer uma credencial com o campo delegate preenchido.
!Atenção! Na versão Orbix este método não considera um comportamento multithread, 
 sendo assim a alteração de credencial será válida para todas as threads.

\begin{lstlisting}
  class LeaseExpiredCallback {
    public:
      virtual void expired() = 0;
  };
\end{lstlisting}

Representa uma callback para a notificação de que o lease da credencial de 
indentificação do usuário expirou. O usuário deve fornecer a implementação 
da callback implementando o método expired().
\begin{lstlisting}
  void setLeaseExpiredCallback(LeaseExpiredCallback* leaseExpiredCallback)
\end{lstlisting}

Registra uma callback para a notificação de lease expirado através de um 
objeto do tipo LeaseExpiredCallback. Este método deve ser chamado após o 
estabelecimento da conexão com o barramento.

\begin{lstlisting}
  void removeLeaseExpiredCallback()
\end{lstlisting}

Remove uma callback previamente registrada para a notificação de lease 
expirado.Este método deve ser chamado após o estabelecimento da conexão 
com o barramento.

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* user,
    const char* password)
    throw (CORBA::SystemException, LOGIN_FAILURE)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com o barramento 
  ocorreu.
  Possíveis causas:
  \begin{itemize}
    \item Os valores que definem a localização do barramento(máquina e porta) 
    estão incorretos.
    \item O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  \end{itemize}
\end{description}

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* entity,
    const char* privateKeyFilename,
    const char* ACSCertificateFilename)
    throw (CORBA::SystemException, LOGIN_FAILURE, SECURITY_EXCEPTION)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento utilizando o mecanismo de 
certificação para o processo de autenticação. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com obarramento 
  ocorreu. Possíveis causas:
  Os valores que definem a localização do barramento(host e porta) estão 
  incorretos.
  O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  \item[SECURITY\_EXCEPTION] Falha no mecanismo de autenticação por certificado 
  digital. Algumas possíveis causas:

  Não foi possível obter o desafio.
  Falha na manipulação de uma chave privada ou pública.
  Falha na manipulação de um certificado.
\end{description}

\begin{lstlisting}
  bool Openbus::disconnect()
\end{lstlisting}

Desfaz a conexão atual. Caso a conexão seja desfeita, true é retornado, caso 
contrário, o valor de retorno é false.

\begin{lstlisting}
  void Openbus::run()
\end{lstlisting}

Loop que processa requisições CORBA.
!Atenção! Este método na versão Mico multithread faz um wait() na RunThread.

\begin{lstlisting}
  void stop()
\end{lstlisting}

Pára de processar requisições CORBA. Finaliza a execução do run.
!Atenção! Não faz nada na versão Mico multithread.

\begin{lstlisting}
  void finish(bool force);
\end{lstlisting}

Finaliza a execução do ORB.

\begin{lstlisting}
  void setInterceptable(
    string interfaceRepID, 
    string method, 
    bool isInterceptable)
\end{lstlisting}

Define se os métodos de uma determinada interface devem ou não ser interceptados pelo
interceptador servidor.

\begin{lstlisting}
  bool isInterceptable(
    string interfaceRepID, 
    string method)
\end{lstlisting}

Consulta se o método está sendo interceptado.

\begin{lstlisting}
  bool isFaultToleranceEnable()
\end{lstlisting}

Consulta se o mecanismo de tolerância a falhas está ativado.

\subsection{Tolerância a falhas}

O usuário Orbix pode habilitar um mecanismo de tolerância a falhas em requisições 
remotas destinadas aos serviços básicos do barramento. Para isto, é necessário 
ter em mãos a lista de réplicas disponíveis para o serviço de acesso, e, descrevê-las 
em um arquivo do tipo Lua. Um exemplo:

\lstset{language=bash}
\begin{lstlisting}
-- replicas.lua
ACSHosts = {
  {"nomeMaquinaA", 2089},
  {"nomeMaquinaB", 4089},
}
\end{lstlisting}

Essas informações devem ser obtidas com o administrador do barramento. A habilitação 
do mecanismo é através do parâmetro de linha de comando \lstinline!-OpenbusFTConfigFilename!, 
que deve receber o caminho relativo ou absoluto do arquivo acima.

\subsection{Dinâmica da Programação}
Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e 
outra que consome serviços. Sendo possível e natural uma aplicação híbrida 
que assuma as duas posições. Para ambos os tipos, existe uma certa 
dinâmica de programação já definida. Justamente a explicitação dessa 
dinâmica que será o objetivo deste tópico. 
Como facilitador, os processos serão demonstrados com base na \emph{demo} Hello. 
Esta demo é composta de um módulo cliente e de outro servidor. O servidor 
oferta um serviço do tipo Hello num determinado barramento, já o cliente 
procura por este serviço no barramento em questão e o utiliza.

\subsection{Conexão com o barramento}
O primeiro passo é firmar uma conexão autenticada com o barramento, o que é 
necessário tanto para o cliente como para o servidor. Para isto é preciso:
\begin{enumerate}
  \item Adquirir a instância que representa o barramento
  \begin{lstlisting}
  openbus::Openbus* bus = Openbus::getInstance();
  \end{lstlisting}
  \item Inicializar essa referência que foi adquirida anteriormente:
  \begin{lstlisting}
  bus->init(argc, argv);
  \end{lstlisting}
  \item Efetuar uma autenticação no barramento através de um certificado 
  digital ou um par usuário e senha:
  \begin{lstlisting}
  services::RegistryService* registryService =
    bus->connect(
      "HelloService", 
      "HelloService.key",
      "AccessControlService.crt");
  \end{lstlisting}

  ou
  
  \begin{lstlisting}
  services::RegistryService* registryService = 
    bus->connect("tester", "tester");
  \end{lstlisting}
  
\end{enumerate}

Existem dois modos de autenticação frente ao barramento:

\begin{enumerate}
  \item Par usuário e senha.
  \item Certificado digital.
\end{enumerate}

O primeiro é destinado normalmente aos clientes que estão acessando o 
barramento através de uma identificação pessoal e intransferível, já o 
segundo é mais adequado a um serviço ou uma aplicação que não necessita 
distinguir os usuários que acessam o barramento. No segundo caso, 
o responsável pelo serviço deve encaminhar ao administrador do barramento o 
certificado do serviço, ou seja, um arquivo especial que contenha a chave 
pública do serviço. Em contrapartida o administrador deve fornecer o 
certificado do serviço de controle de acesso. 

\subsection{Registro de serviço}

Um serviço pode ser disponibilizado no barramento através de uma oferta de 
serviço (ServiceOffer), que é uma estrutura que representa o serviço através 
de uma lista de propriedades (properties) e de uma referência para um 
componente (member) SCS. 


\begin{lstlisting}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{lstlisting}

Através da lista de propriedades é possível caracterizar o serviço. 
A arquitetura do Openbus é baseada no modelo de componentes SCS. O 
serviço é representado por um componente que pode apresentar 
distintas facetas (interfaces). Sendo assim, o primeiro passo para o 
registro de um serviço é criar um componente que represente o serviço 
desejado. 
Uma fábrica de componentes (componentBuilder) pode ser adquirida 
através do método \emph{Openbus::getComponentBuilder()}.  
De posse desta fábrica, o usuário pode criar um componente atribuindo uma 
ou mais facetas:

\begin{lstlisting}
/* Fabrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definicao do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descricao das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);
\end{lstlisting}

O serviço a ser registrado no barramento deve ser descrito através de uma 
oferta de serviço, que é representada pela estrutura ServiceOffer. 
Pendura-se nesta estrutura o serviço em si, que é representado através de 
um componente SCS e opcionalmente uma lista de propriedades referentes ao 
mesmo.
As propriedades devem ser descritas através de uma estrutura do tipo lista. 
Como esta lista é uma \emph{sequence} de uma estrutura que possui 
uma outra lista, que é justamente a lista de valores, pois uma chave pode 
estar relacionada a mais de um valor, o preenchimento dos valores desejados 
envolve um número de linhas de código um tanto indesejável. Por este motivo, 
há a classe de auxílio PropertyListHelper que tem por objetivo facilitar o 
trabalho de construção das listas de propriedades.
Por exemplo, se o usuário desejar criar uma lista que contenha somente uma 
propriedade do tipo chave/valor, o mesmo deveria entrar com algo do tipo:

\begin{lstlisting}
openbusidl::rs::PropertyList_var p = new openbusidl::rs::PropertyList(1);
  p->length(1);
  openbusidl::rs::Property_var property = new openbusidl::rs::Property;
  property->name = "description";
  openbusidl::rs::PropertyValue_var propertyValue = 
    new openbusidl::rs::PropertyValue(1);

  propertyValue->length(1);
  propertyValue[0] = "Serviço IHello";
  property->value = propertyValue;
  p[0] = property;
\end{lstlisting}

Agora, se a classe de auxílio for utilizada, reduzimos este código para:

\begin{lstlisting}
  openbus::util::PropertyListHelper* propertyListHelper = 
    new openbus::util::PropertyListHelper();

/* Criação de uma *oferta de serviço*. */
  registry_service::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;
\end{lstlisting}

De posse da lista de propriedades e do componente que representa o serviço, 
é possível requisitar o registro do serviço:

\begin{lstlisting}
registryId = registryService->_cxx_register(serviceOffer);
\end{lstlisting}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou 
o serviço. O último passo necessário para se finalizar o código do servidor é 
habilitar o processo servidor a escutar as requisições CORBA que serão 
direcionadas para o serviço ofertado:

\begin{lstlisting}
bus->run();
\end{lstlisting}

\subsection{Processo cliente}

Como o servidor, o cliente necessita se autenticar no barramento, portanto
os mesmos passos aplicados no servidor para a autenticação devem ser 
repetidos, com exceção de que o cliente provavelmente vai desejar se 
autenticar com o barramento através do mecanismo usuário e senha:

\begin{lstlisting}
  registryService = bus->connect("tester", "tester");
\end{lstlisting}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o 
serviço desejado. Isso pode ser feito através de uma chamada ao método 
services::RegistryService::find(), que retorna uma lista de ofertas de 
serviço que implementam a faceta que o usuário deseja.

Busca do serviço:

\begin{lstlisting}
/* Define a lista de facetas que caracteriza o serviço implementado.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::util::FacetListHelper* facetListHelper =
    new openbus::util::FacetListHelper();
  facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  registry_service::ServiceOfferList_var serviceOfferList =
    registryService->find(facetListHelper->getFacetList());
  delete facetListHelper;

  registry_service::ServiceOffer serviceOffer = serviceOfferList[(CORBA::ULong) 0];
\end{lstlisting}

Como visto acima, a oferta de serviço armazena o serviço através de um 
componente SCS. Como este componente pode apresentar diversas facetas, 
o usuário deve informar qual faceta deseja utilizar. No exemplo utilizado, 
somente há uma faceta IHello. O componente oferece um 
método(getFacet) para que o usuário possa obter um objeto CORBA que 
represente o serviço desejado:

\begin{lstlisting}
scs::core::IComponent_var component = serviceOffer.member;
CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
\end{lstlisting}

De posse do objeto CORBA, o usuário deve efetuar um narrow para mapeá-lo para 
a interface desejada:

\begin{lstlisting}
demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);
\end{lstlisting}

Daqui em diante o programador estará apto a utilizar o serviço.

\clearpage
\subsection{Código servidor}

\begin{lstlisting}
/*
** OpenBus Demo - Mico
** server.cpp
*/

#include <fstream>
#include <iostream>
#include <CORBA.h>
#include <csignal>

#include <openbus.h>
#include <ComponentBuilder.h>

#include "stubs/hello.h"

using namespace std;
using namespace tecgraf::openbus::core::v1_05;
using namespace tecgraf::openbus::core::v1_05::registry_service;

openbus::Openbus* bus;
registry_service::IRegistryService* registryService = 0;
char* registryId;
scs::core::ComponentContext* componentContext;
const char* entityName;
const char* privateKeyFilename;
const char* ACSCertificateFilename;
const char* facetName;

class HelloImpl : virtual public POA_demoidl::hello::IHello {
  private:
    scs::core::ComponentContext* componentContext;
    HelloImpl(scs::core::ComponentContext* componentContext) {
      this->componentContext = componentContext;
    }
  public:
    static PortableServer::ServantBase* instantiate(
      scs::core::ComponentContext* componentContext) 
    {
      return (PortableServer::ServantBase*) new HelloImpl(componentContext);
    }
    static void destruct(void* obj) {
      delete (HelloImpl*) obj;
    }
    void sayHello() throw(CORBA::SystemException) {
      cout << "Servant diz: HELLO!" << endl;
      access_control_service::Credential_var credential = 
        bus->getInterceptedCredential();
      cout << "Usuario OpenBus que fez a chamada: " << credential->owner.in()
        << endl;
    };
};

void termination_handler(int p) {
  cout << "Encerrando o processo servidor..." << endl;
  openbus::Openbus::terminationHandlerCallback((long) signal);
}

void commandLineParse(int argc, char* argv[]) {
  for (short i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "-EntityName")) {
      i++;
      entityName = argv[i];
    } else if (!strcmp(argv[i], "-PrivateKeyFilename")) {
      i++;
      privateKeyFilename = argv[i];
    } else if (!strcmp(argv[i], "-ACSCertificateFilename")) {
      i++;
      ACSCertificateFilename = argv[i];
    } else if (!strcmp(argv[i], "-FacetName")) {
      i++;
      facetName = argv[i];
    } 
  }
}

int main(int argc, char* argv[]) {
  signal(SIGINT, termination_handler);
  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);

  commandLineParse(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexao com o barramento atraves de certificado. */
  try {
    registryService = bus->connect(
      entityName, 
      privateKeyFilename,
      ACSCertificateFilename);
  } catch (CORBA::SystemException& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Falha na comunicacao. *" << endl;
    exit(1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Par usuario/senha invalido. *" << endl;
    exit(1);
  } catch (openbus::SECURITY_EXCEPTION& e) {
    cout << e.what() << endl;
    exit(1);
  }

  cout << "Conexao com o barramento estabelecida com sucesso!" << endl;

/* Fabrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definicao do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descricao das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = facetName;
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);

  openbus::util::PropertyListHelper* propertyListHelper = \
    new openbus::util::PropertyListHelper();

/* Criacao de uma *oferta de servico*. */
  registry_service::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;

  cout << "Registrando servico IHello no barramento..." << endl;

/* Registro do servico no barramento. */
  try {
    if (registryService) {
      registryId = registryService->_cxx_register(serviceOffer);
    } else {
      cout << "Nao foi possivel adquirir um proxy para o servico de registro." 
        << endl;
      exit(1);
    }
  } catch (UnathorizedFacets& e) {
    cout << "Nao foi possivel registrar IHello." << endl;
    CORBA::ULong idx;
    CORBA::ULong length = e.facets.length();
    for (idx = 0; idx < length; idx++) {
      cout << "Faceta nao autorizada: " << e.facets[idx] << endl;
    }
    exit(1);
  }
  cout << "Servico IHello registrado." << endl;
  cout << "Aguardando requisicoes..." << endl;

  bus->run();

  return 0;
}

\end{lstlisting}

\subsection{Código cliente}

\begin{lstlisting}
/*
** OpenBus Demo - Mico
** client.cpp
*/

#include <fstream>
#include <iostream>

#include "stubs/hello.h"
#include <openbus.h>

using namespace std;
using namespace tecgraf::openbus::core::v1_05;

const char* busUser;
const char* busPassword;
const char* facetName;

void commandLineParse(int argc, char* argv[]) {
  for (short i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "-BusUser")) {
      i++;
      busUser = argv[i];
    } else if (!strcmp(argv[i], "-BusPassword")) {
      i++;
      busPassword = argv[i];
    } else if (!strcmp(argv[i], "-FacetName")) {
      i++;
      facetName = argv[i];
    } 
  }
}

int main(int argc, char* argv[]) {
  openbus::Openbus* bus;
  registry_service::IRegistryService* registryService;

  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);
  
  commandLineParse(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexão com o barramento. */
  try {
    registryService = bus->connect(
      busUser,
      busPassword);
  } catch (CORBA::SystemException& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Falha na comunicacao. *" << endl;
    exit(-1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Par usuario/senha inválido. *" << endl;
    exit(-1);
  }

  cout << "Conexão com o barramento estabelecida com sucesso!" << endl;

/* Define a lista de facetas que caracteriza o serviço implementa.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::util::FacetListHelper* facetListHelper =
    new openbus::util::FacetListHelper();
  facetListHelper->add(facetName);

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  registry_service::ServiceOfferList_var serviceOfferList =
    registryService->find(facetListHelper->getFacetList());
  delete facetListHelper;

  if (serviceOfferList->length() > 0) {
    registry_service::ServiceOffer serviceOffer = serviceOfferList[(CORBA::ULong) 0];
  
    scs::core::IComponent_var component = serviceOffer.member;
    CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
    demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);

    cout << "Fazendo chamada remota sayHello()..." << endl;

    hello->sayHello();
  } else {
    cout << "Nenhuma oferta encontrada." << endl;
  }
  
  cout << "Desconectando-se do barramento..." << endl;

  bus->disconnect();
  delete bus;

  return 0;
}

\end{lstlisting}

\end{document}

