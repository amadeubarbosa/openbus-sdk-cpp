\documentclass[a4paper, 11pt]{article}
\usepackage{a4}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{listings}
\usepackage{verbatim}

\lstset{
  language = c++, 
  breaklines = true,
  breakatwhitespace = true,
  showlines = true
}

\title{Tutorial Openbus C++}
\author{R. Cosme, C. Augusto, R. Cerqueira \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{\today}


\begin{document}
\maketitle

\section{Introdução}
Este documento é destinado aos usuários desenvolvedores de aplicações C++ que  
desejam utilizar o Openbus. O processo de \emph{deployment} do barramento não é 
coberto aqui neste tutorial. Considera-se como pré-requisitos para um bom   
entendimento deste documento um conhecimento básico dos seguintes assuntos:

\begin{itemize}
  \item Linguagem de programação C++.
  \item CORBA.
  \item Modelo de Componentes SCS.
  \item Conceitos básicos do Openbus.
\end{itemize}

\section{Preparação do Ambiente}
O Openbus é desenvolvido em CORBA, portanto é necessária a presença de 
um ORB específico para a versão da biblioteca que o desenvolvedor 
possui. Este ORB 
a ser utilizado, precisa habilitar o mecanismo de interceptação de CORBA, 
pois o Openbus utiliza este recurso no processo de controle de acesso aos 
serviços. 

Após a chamada de requisição de login no barramento, todas as chamadas 
seguintes devem estar com a credencial de acesso anexada. Sendo assim, 
faz-se necessário a habilitação dos interceptadores frente ao ORB que será 
utilizado.

Alguns ORB's ativam este mecanismo por padrão, como o MICO. Outros necessitam 
de algumas configurações específicas, como é o caso do Orbix.

\subsection{Orbix 6.3 Service Pack 3}
Este ORB é configurável através de domínios de configuração que por sua vez 
formam um ambiente. O domínio é formado por escopos, e, é representado através 
de um arquivo textual que pode ser editado diretamente pelo administrador. 
Neste arquivo, as seguintes modificações devem ser realizadas no devido escopo:

\lstset{language=bash}
\begin{itemize}
  \item Adicionar o \emph{plugin}(\verb!portable_interceptor!) responsável pela 
  interceptação
  na lista \verb!orb_plugins!.
  Ex.:
  \begin{lstlisting}
  orb_plugins = [
    "local_log_stream", 
    "iiop_profile", 
    "giop", 
    "iiop", 
    "portable_interceptor"
  ];   
  \end{lstlisting}
  \item O nome do interceptador cliente(AccessControl) deve 
  constar na lista 
  \verb!client_binding_list!. 
  Ex.: 
  \begin{lstlisting}
  binding:client_binding_list = [
    "AccessControl+OTS+POA_Coloc", 
    "AccessControl+POA_Coloc", 
    "OTS+POA_Coloc",
    "POA_Coloc", 
    "AccessControl+OTS+GIOP+IIOP", 
    "AccessControl+GIOP+IIOP", 
    "OTS+GIOP+IIOP", 
    "GIOP+IIOP"
  ];
  \end{lstlisting}
  \item O nome do interceptador servidor(AccessControl) deve 
  constar na lista 
  server\_binding\_list.
  Ex.: 
  \begin{lstlisting}
  binding:server_binding_list = [
    "OTS+AccessControl", 
    "AccessControl", 
    "OTS", 
    ""
  ];
  \end{lstlisting}
\end{itemize}
  
\section{Teste}
Antes de se começar a programação, é aconselhável que o usuário coloque em 
funcionamento  o \emph{demo} Hello que acompanha o pacote. O correto funcionamento 
do \emph{demo}, elimina uma série de possíveis problemas que o desenvolvedor possa 
enfrentar durante o seu projeto, como por exemplo: problemas de comunicação 
com o barramento, mecanismo de interceptação não habilitado e ausência de 
bibliotecas dinâmicas externas.
Naturalmente a execução do \emph{demo} necessita de um barramento em operação. 
O \emph{demo} pode ser executado seguindo os seguintes passos:

\begin{enumerate}
  \item Entrar no diretório \lstinline!$OPENBUS\HOME/demo/hello/orbix63!.
  \item Editar o arquivo \lstinline!$OPENBUS\HOME/demo/hello/orbix63/democonfig!
  e configurar a localização do barramento.
  \item Executar o processo servidor: \lstinline!./runserver!

  A mensagem "Serviço HELLO registrado no OpenBus..." deve ser retornada.
  \item Executar o processo cliente: \lstinline!./runclient!

  Após a execução do cliente, no terminal do processo servidor a seguinte 
  mensagem deve ser retornada: "Servant diz: HELLO!".
\end{enumerate}

Aconselha-se que o primeiro teste seja feito com o processo servidor e 
cliente na mesma máquina. O arquivo democonfig apresenta por padrão as 
configurações para este tipo de teste.
É interessante que este teste também seja realizado, se possível, utilizando-se
as máquinas finais que serão utilizadas no projeto do desenvolvedor. Problemas
de comunicação podem ocorrer por conta das configurações de rede das máquinas 
envolvidas. 

\section{Desenvolvimento}
\subsection{API}
\lstset{language=c++}
A API é composta pelos módulos openbus.h e RegistryService.h.

\begin{lstlisting}
  static Openbus::getInstance()
\end{lstlisting}

Fornece a instância que representa um determinado barramento.

\begin{lstlisting}
  void Openbus::init(
  int argc,
  char** argv)
\end{lstlisting}

Inicializa a referência para o barramento.
Um ORB e um POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Parâmetros de linha de comando:
\begin{description}
  \item[-OpenbusHost] Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-TimeRenewing] Tempo em milisegundos de renovação da credencial.
\end{description}

\begin{lstlisting}
  void Openbus::init(
    int argc,
    char** argv,
    char* host,
    unsigned short port)
\end{lstlisting}

Inicializa a referência para o barramento.
Um ORB e POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Parâmetros de linha de comando:
\begin{description}
  \item[-OpenbusHost] Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-TimeRenewing] Tempo em milisegundos de renovação da credencial.
\end{description}

\begin{lstlisting}
  bool Openbus::isConnected()
\end{lstlisting}

Informa o estado de conexão com o barramento.

\begin{lstlisting}
  static void Openbus::terminationHandlerCallback(long signalType)
\end{lstlisting}

Termination Handler disponível para a classe IT\_TerminationHandler(). 
Este método desfaz a conexão para cada instância de barramento. 
Vide server.cpp do \emph{demo} Hello. 

\begin{lstlisting}
  CORBA::ORB* Openbus::getORB()
\end{lstlisting}

Retorna o ORB utilizado.

\begin{lstlisting}
  PortableServer::POA* getRootPOA();
\end{lstlisting}

Retorna o RootPOA.

\begin{lstlisting}
  scs::core::ComponentBuilder* Openbus::getComponentBuilder()
\end{lstlisting}

Retorna a fábrica de componentes.

\begin{lstlisting}
  Credential_var Openbus::getInterceptedCredential()
\end{lstlisting}

Retorna a credencial interceptada pelo interceptador servidor. 
Esta operação somente deve ser chamada durante o processo de 
tratamento de requisição do serviço implementado.  

\begin{lstlisting}
  openbusidl::acs::IAccessControlService* Openbus::getAccessControlService()
\end{lstlisting}

Retorna o serviço de acesso.

\begin{lstlisting}
  services::RegistryService* getRegistryService(); 
\end{lstlisting}

Retorna o serviço de registro.

\begin{lstlisting}
  openbusidl::ss::ISessionService* getSessionService()
    throw(NO_CONNECTED, NO_SESSION_SERVICE); 
\end{lstlisting}

Retorna o serviço de sessão.
Se a tentativa for bem sucedida, uma instância que representa 
o serviço de sessão é retornada, caso contrário duas exceções podem ser 
lançadas:

\begin{description}
  \item[NO\_CONNECTED] Não há uma conexão estabelecida com nenhum barramento.
  \item[NO\_SESSION\_SERVICE] Não é possível obter, a nível de CORBA, o serviço
  de sessão no barramento em uso.
\end{description}

\begin{lstlisting}
  Credential* Openbus::getCredential()
\end{lstlisting}

Retorna a credencial de identificação do usuário frente ao barramento.

\begin{lstlisting}
  void setThreadCredential(Credential* credential)
\end{lstlisting}

Define uma credencial a ser utilizada no lugar da credencial corrente.
Útil para fornecer uma credencial com o campo delegate preenchido.

\begin{lstlisting}
  class LeaseExpiredCallback {
    public:
      virtual void expired() = 0;
  };
\end{lstlisting}

Representa uma callback para a notificação de que o lease da credencial de 
indentificação do usuário expirou. O usuário deve fornecer a implementação 
da callback implementando o método expired().

\begin{lstlisting}
  void setLeaseExpiredCallback(LeaseExpiredCallback* leaseExpiredCallback)
\end{lstlisting}

Registra uma callback para a notificação de lease expirado através de um 
objeto do tipo LeaseExpiredCallback. Este método deve ser chamado após o 
estabelecimento da conexão com o barramento.

\begin{lstlisting}
  void removeLeaseExpiredCallback()
\end{lstlisting}

Remove uma callback previamente registrada para a notificação de lease 
expirado.Este método deve ser chamado após o estabelecimento da conexão 
com o barramento.

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* user,
    const char* password)
    throw (CORBA::SystemException, LOGIN_FAILURE)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com o barramento 
  ocorreu.
  Possíveis causas:
  \begin{itemize}
    \item Os valores que definem a localização do barramento(host e porta) 
    estão incorretos.
    \item O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  \end{itemize}
\end{description}

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* entity,
    const char* privateKeyFilename,
    const char* ACSCertificateFilename)
    throw (CORBA::SystemException, LOGIN_FAILURE, SECURITY_EXCEPTION)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento utilizando o mecanismo de 
certificação para o processo de autenticação. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com obarramento 
  ocorreu. Possíveis causas:
  Os valores que definem a localização do barramento(host e porta) estão 
  incorretos.
  O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  SECURITY\_EXCEPTION: Falha no mecanismo de autenticação por certificado 
  digital. Algumas possíveis causas:

  Não foi possível obter o desafio.
  Falha na manipulação de uma chave privada ou pública.
  Falha na manipulação de um certificado.
\end{description}

\begin{lstlisting}
  bool Openbus::disconnect()
\end{lstlisting}

Desfaz a conexão atual. Caso a conexão seja desfeita, true é retornado, caso 
contrário, o valor de retorno é false.

\begin{lstlisting}
  void Openbus::run()
\end{lstlisting}

Loop que processa requisições remotas. Execução do orb->run().

\begin{lstlisting}
  void finish(bool force);
\end{lstlisting}

Finaliza a execução do ORB.

\begin{lstlisting}
  void services::RegistryService::Register(
    ServiceOffer serviceOffer, 
    char* registryId)
\end{lstlisting}

Registra um serviço no barramento. O serviço é descrito através de uma 
oferta de serviço. Caso o serviço seja registrado com sucesso, a 
identificação do mesmo é armazenada no parâmetro de saída registryId.

\begin{lstlisting}
  void services::RegistryService::unregister(char* registryId)
\end{lstlisting}

Remove uma oferta de serviço do barramento. Se a remoção ocorrer com sucesso,
o valor true é retornado, caso contrário false é retornado.

\begin{lstlisting}
  ServiceOfferList* services::RegistryService::find(FacetList facets);
\end{lstlisting}

Busca uma ou mais ofertas de serviço no barramento que implementam todas as
facetas discriminadas em facets.

\begin{lstlisting}
  ServiceOfferList* services::RegistryService::findByCriteria(
    FacetList facets,
    PropertyList properties);
\end{lstlisting}

Busca uma ou mais ofertas de serviço no barramento que implementam todas as 
as facetas discriminadas em facets, e, que atendam aos critérios descritos no 
parâmetro criteria, que é uma lista de propriedades descrita através de strings
no formato  chave = {valor1, valor2, ..., valorN}.

\subsection{Primeiros passos...}
Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e 
outra que consome serviços. Sendo possível e natural uma aplicação híbrida 
que tanto oferte quanto consuma. Para ambos os tipos, existe uma certa 
dinâmica de programação já definida. E é justamente a explicitação dessa 
dinâmica que será o objetivo deste tópico. 
Como facilitador, os processos serão demonstrados com base no \emph{demo} Hello. 
De propósito, este é um \emph{demo} muito simplório, que é composto de um módulo 
cliente e de outro servidor. O servidor oferta um serviço do tipo Hello 
num determinado barramento, já o cliente procura por este serviço no 
barramento e o utiliza.

\subsection{Conexão com o barramento}
O primeiro passo é firmar uma conexão autenticada com o barramento, o que é 
necessário tanto para o cliente como para o servidor. Para se concluir a 
conexão é preciso:
\begin{enumerate}
  \item Adquirir a instância que representa o barramento
  \begin{lstlisting}
  openbus::Openbus* bus = Openbus::getInstance();
  \end{lstlisting}
  \item Inicializar essa referência bus:
  \begin{lstlisting}
  bus->init(argc, argv);
  \end{lstlisting}
  \item Efetuar uma autenticação no barramento através do certificado do 
  serviço:
  \begin{lstlisting}
  services::RegistryService* registryService =
    bus->connect(
      "HelloService", 
      "HelloService.key",
      "AccessControlService.crt");
  \end{lstlisting}
\end{enumerate}

Existem dois modos de autenticação frente ao barramento:

\begin{enumerate}
  \item Par usuário e senha.
  \item Certificado digital.
\end{enumerate}

O primeiro é destinado normalmente aos clientes que estão acessando o 
barramento a procura de um serviço, já o segundo é mais adequado ao processo 
servidor que estará registrando um determinado serviço no barramento.
O responsável pelo serviço deve encaminhar ao administrador do barramento o 
certificado do serviço, ou seja, um arquivo especial que contenha a chave 
pública do serviço, dentre outras informações pertinentes. O administrador 
deve fornecer o certificado do serviço de controle de acesso. 

\subsection{Registro de serviço}

Um serviço pode ser colocado no barramento através de uma oferta de 
serviço (ServiceOffer), que é uma estrutura que representa o serviço através 
de uma lista de propriedades (properties) e de uma referência para um 
componente (member) SCS. 


\begin{lstlisting}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{lstlisting}

Através da lista de propriedades, é possível caracterizar o serviço. 
A arquitetura do Openbus é baseada no modelo de componentes SCS. O 
serviço é de fato representado por um componente, que pode apresentar 
distintas facetas (interfaces). Sendo assim, o primeiro passo para o 
registro de um serviço, é criar um componente que represente o serviço 
desejado. 
Uma fábrica de componentes (componentBuilder) pode ser adquirida 
através do método \emph{Openbus::getComponentBuilder()}.  
De posse desta fábrica, o usuário pode criar um componente pendurando uma 
ou mais facetas:

\begin{lstlisting}
/* Fábrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definição do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descrição das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  scs::core::ComponentContext* componentContext =
    componentBuilder->newFullComponent(extFacets, componentId);
\end{lstlisting}

O serviço a ser registrado no barramento deve ser descrito através de uma 
oferta de serviço, que é representada pela estrutura ServiceOffer. 
Pendura-se nesta estrutura o serviço em si, que é representado através de 
um componente SCS, e, opcionalmente uma lista de propriedades referentes ao 
serviço.
As propriedades devem ser descritas numa estrutura que represente uma lista 
de propriedades. Como esta lista é uma sequence de uma estrutura que possui 
uma outra lista, que é justamente a lista de valores, pois uma chave pode 
estar relacionada a mais de um valor, o preenchimento dos valores desejados 
envolve um número de linhas de código um tanto indesejável. Por este motivo, 
há a classe de auxílio PropertyListHelper que tem por objetivo facilitar o 
trabalho de construção das listas de propriedades.
Por exemplo, se o usuário desejar criar uma lista que contenha somente uma 
propriedade do tipo chave/valor, o mesmo deveria entrar com algo do tipo:

\begin{lstlisting}
openbusidl::rs::PropertyList_var p = new openbusidl::rs::PropertyList(1);
  p->length(1);
  openbusidl::rs::Property_var property = new openbusidl::rs::Property;
  property->name = "description";
  openbusidl::rs::PropertyValue_var propertyValue = 
    new openbusidl::rs::PropertyValue(1);

  propertyValue->length(1);
  propertyValue[0] = "Serviço IHello";
  property->value = propertyValue;
  p[0] = property;
\end{lstlisting}

Agora, se a classe de auxílio for utilizada, reduzimos este código para:

\begin{lstlisting}
openbus::services::PropertyListHelper* PropertyListHelper =
    new openbus::services::PropertyListHelper();
  PropertyListHelper->add("description", "Serviço IHello");

  
  openbusidl::rs::ServiceOffer serviceOffer;
  serviceOffer.properties = PropertyListHelper->getPropertyList();
  serviceOffer.member = Icomponent->_this();
\end{lstlisting}

De posse da lista de propriedades e do componente que representa o serviço, 
é possível requisitar o registro do serviço:

\begin{lstlisting}
registryService->Register(serviceOffer, registryId);
\end{lstlisting}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou 
o serviço. O último passo necessário para se finalizar o código do servidor é 
habilitar o processo servidor a escutar as requisições CORBA que serão 
direcionadas para o serviço ofertado:

\begin{lstlisting}
bus->run();
\end{lstlisting}

\subsection{Processo cliente}

Como o servidor, o cliente necessita se autenticar no barramento, portanto, 
os mesmos passos aplicados no servidor para a autenticação devem ser 
repetidos, com exceção de que o cliente se autentica através do mecanismo 
usuário e senha:

\begin{lstlisting}
services::RegistryService* registryService =
      bus->connect(USER, PASSWORD);
\end{lstlisting}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o 
serviço desejado. Isso pode ser feito através de uma chamada ao método 
services::RegistryService::find(), que retorna uma lista de ofertas de 
serviço que implementam a faceta que o usuário deseja.

Busca do serviço:

\begin{lstlisting}
/* Define a lista de facetas que caracteriza o serviço implementa.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::services::FacetListHelper* facetListHelper = \
    new openbus::services::FacetListHelper();
  facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  openbus::services::ServiceOfferList_var serviceOfferList = \
    registryService->find(facetListHelper->getFacetList());

 CORBA::ULong idx = 0;
 openbus::services::ServiceOffer serviceOffer = serviceOfferList[idx];
\end{lstlisting}

Como visto acima, a oferta de serviço armazena o serviço através de um 
componente SCS. Como este componente pode apresentar diversas facetas, 
o usuário deve informar qual faceta deseja utilizar. No exemplo utilizado, 
somente há uma faceta, que é a IHello. O componente oferece um 
método(getFacet) para que o usuário possa obter um objeto CORBA que 
represente o serviço desejado:

\begin{lstlisting}
scs::core::IComponent* component = serviceOffer.member;
  CORBA::Object* obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
\end{lstlisting}

De posse do objeto CORBA, o usuário deve efetuar um narrow para mapeá-lo para 
a interface desejada:

\begin{lstlisting}
demoidl::hello::IHello* hello = demoidl::hello::IHello::_narrow(obj);
\end{lstlisting}

Daqui em diante o programador estará apto a utilizar o serviço.

\clearpage
\subsection{Código servidor}

\texttt{../demo/hello/orbix63/server.cpp} \\

\begin{lstlisting}
/*
** OpenBus Demo - Orbix 6.3
** server.cpp
*/

#include <fstream>
#include <iostream>
#include <omg/orb.hh>
#include <it_ts/thread.h>
#include <it_ts/termination_handler.h>

#include <openbus.h>
#include <ComponentBuilderOrbix.h>

#include "stubs/helloS.hh"

using namespace std;

IT_USING_NAMESPACE_STD

openbus::Openbus* bus;
openbus::services::RegistryService* registryService;
char* registryId;
scs::core::ComponentContext* componentContext;

class HelloImpl : virtual public POA_demoidl::hello::IHello {
  private:
    scs::core::ComponentContext* componentContext;
    HelloImpl(scs::core::ComponentContext* componentContext) {
      this->componentContext = componentContext;
    }
  public:
    static void* instantiate(scs::core::ComponentContext* componentContext) {
      return (void*) new HelloImpl(componentContext);
    }
    static void destruct(void* obj) {
      delete (HelloImpl*) obj;
    }
    void sayHello() IT_THROW_DECL((CORBA::SystemException)) {
      cout << "Servant diz: HELLO!" << endl;
      openbusidl::acs::Credential_var credential = 
        bus->getInterceptedCredential();
      cout << "Usuario OpenBus que fez a chamada: " << credential->owner.in()
        << endl;
    };
};

static void myTerminationHandler(long signal) {
  cout << "Encerrando o processo servidor..." << endl;
  try {
    registryService->unregister(registryId);
  } catch(CORBA::Exception& e) {
    cout << "Não foi possível remover a oferta de serviço." << endl;
  }
  delete componentContext;
  openbus::Openbus::terminationHandlerCallback(signal);
}

int main(int argc, char* argv[]) {
  IT_TerminationHandler termination_handler(myTerminationHandler);

  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexão com o barramento através de certificado. */
  try {
    registryService = bus->connect("HelloService", "HelloService.key",
      "AccessControlService.crt");
  } catch (CORBA::SystemException& e) {
    cout << "** Não foi possível se conectar ao barramento. **" << endl \
         << "* Falha na comunicação. *" << endl;
    exit(-1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Não foi possível se conectar ao barramento. **" << endl \
         << "* Par usuário/senha inválido. *" << endl;
    exit(-1);
  } catch (openbus::SECURITY_EXCEPTION& e) {
    cout << e.what() << endl;
    exit(-1);
  }

  cout << "Conexão com o barramento estabelecida com sucesso!" << endl;

/* Fábrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definição do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descrição das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);

  openbus::services::PropertyListHelper* propertyListHelper = \
    new openbus::services::PropertyListHelper();

/* Criação de uma *oferta de serviço*. */
  openbus::services::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;

  cout << "Registrando serviço IHello no barramento..." << endl;

/* Registro do serviço no barramento. */
  registryService->Register(serviceOffer, registryId);
  cout << "Serviço IHello registrado." << endl;
  cout << "Aguardando requisições..." << endl;

  bus->run();

  return 0;
}

\end{lstlisting}

\clearpage
\subsection{Código cliente}

\begin{lstlisting}
/*
** OpenBus Demo - Orbix 6.3
** client.cpp
*/

#include <fstream>
#include <iostream>

#include "stubs/hello.hh"
#include <openbus.h>

using namespace std;

int main(int argc, char* argv[]) {
  openbus::Openbus* bus;
  openbus::services::RegistryService* registryService;

  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexão com o barramento. */
  try {
    registryService = bus->connect("tester", "tester");
  } catch (CORBA::SystemException& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Falha na comunicacao. *" << endl;
    exit(-1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Par usuario/senha inválido. *" << endl;
    exit(-1);
  }

  cout << "Conexão com o barramento estabelecida com sucesso!" << endl;

/* Define a lista de facetas que caracteriza o serviço implementa.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::services::FacetListHelper* facetListHelper =
    new openbus::services::FacetListHelper();
  facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  openbus::services::ServiceOfferList_var serviceOfferList =
    registryService->find(facetListHelper->getFacetList());
  delete facetListHelper;


  CORBA::ULong idx = 0;
  openbus::services::ServiceOffer serviceOffer = serviceOfferList[idx];

  scs::core::IComponent_var component = serviceOffer.member;
  CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
  demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);

  cout << "Fazendo chamada remota sayHello()..." << endl;

  hello->sayHello();

  cout << "Desconectando-se do barramento..." << endl;

  bus->disconnect();
  delete bus;

  return 0;
}

\end{lstlisting}

\end{document}

