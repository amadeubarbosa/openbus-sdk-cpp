\documentclass[a4paper, 11pt]{article}
\usepackage{a4}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{hyperref}

\lstset{
  language = c++, 
  breaklines = true,
  breakatwhitespace = true,
  showlines = true
}

\title{Tutorial Openbus C++ 1.5.0}
\author{R. Cosme, C. Augusto, R. Cerqueira \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{\today}


\begin{document}
\maketitle

\section{Introdução}
Este documento é destinado aos usuários desenvolvedores de aplicações C++ que desejam utilizar o Openbus. O processo de \emph{deployment} do barramento não é coberto aqui neste tutorial. Considera-se como pré-requisitos para um bom entendimento deste documento um conhecimento básico dos seguintes assuntos:

\begin{itemize}
  \item Linguagem de programação C++.
  \item CORBA.
  \item Modelo de Componentes SCS.
  \item Conceitos básicos do Openbus.
\end{itemize}

\section{Preparação do Ambiente}
O Openbus C++ suporta os ORB`s Mico 2.3.13 e Orbix 6.3 sp3. O usuário Mico pode escolher entre 
a versão single ou multi thread. Abaixo explicamos o que deveria ser feito na configuração 
destes ORB`s para que o usuário possa utilizar o Openbus. Assumimos que o usuário tenha adquirido 
o ORB através de um pacote Openbus SDK C++ obtido em nosso site, ou que já tenha o ORB devidamente 
instalado e apto a alterações em suas configurações.

\subsection {Mico 2.3.13} 

Para que se possa utilizar o Mico, deveria somente ser necessário carregar no shell do usuário 
o arquivo de configurações \lstinline!mico-setup.sh!, para usuários tipo *bash*, ou, \lstinline!mico-setup.csh! para usuários tipo *csh*. O usuário que já tem o Mico instalado, 
deve verificar se este arquivo está sendo carregado no seu ambiente. Este script fica localizado 
na pasta \lstinline!lib! da instalação do Mico. 
No caso do usuário que deseja utilizar o Mico compilado que é oferecido pelo pacote Openbus SDK
 C++, o script acima será encontrado no diretório \lstinline!specs/shell! da instalação do 
 pacote.
 
\subsection {Orbix 6.3 sp3}
No Orbix o usuário precisa habilitar o mecanismo de interceptação de CORBA, pois o Openbus
 utiliza este recurso no processo de controle de acesso aos serviços, e o Orbix não disponibiliza 
 este mecanismo por padrão. O usuário também precisa carregar um script de configuração do 
 ambiente no seu shell.
 
Este ORB é configurável através de domínios de configuração que por sua vez 
formam um ambiente. O domínio é formado por escopos, e, é representado através 
de um arquivo textual que pode ser editado diretamente pelo administrador. 
Não vamos abordar aqui como criar um domínio, para tal o usuário deve consultar a documentação 
do ORB.

Considerando-se que o usuário tenha o seu domínio, as seguintes linhas abaixo devem ser adicionadas no arquivo de configuração do domínio:

\lstset{language=bash}
\begin{lstlisting}
tecgraf {
  openbus {
    policies:giop:interop_policy:ignore_message_not_consumed = "true";
    orb_plugins = [
      "local_log_stream", 
      "iiop_profile", 
      "giop", 
      "iiop", 
      "portable_interceptor"
    ];
    binding:server_binding_list = [
      "OTS+AccessControl", 
      "AccessControl", 
      "OTS", 
      ""
    ];
    binding:client_binding_list = [
      "AccessControl+OTS+POA_Coloc", 
      "AccessControl+POA_Coloc", 
      "OTS+POA_Coloc", 
      "POA_Coloc", 
      "AccessControl+OTS+GIOP+IIOP", 
      "AccessControl+GIOP+IIOP", 
      "OTS+GIOP+IIOP", 
      "GIOP+IIOP"
    ];
  };
};
\end{lstlisting}

As quatro diretivas necessárias para o correto funcionamento do Openbus são 
definidas no escopo \lstinline!tecgraf.openbus!. A primeira define uma política necessária para que IIOP.NET possa se comunicar com o Openbus Orbix. A segunda carrega 
o plugin responsável pelo mecanismo de interceptação. As duas últimas registram 
o interceptador (\lstinline!AccessControl!).
  
Por último, o usuário deve se certificar que o script shell que configura o domínio a ser 
utilizado foi carregado, este arquivo é gerado como resultado do processo de configuração.

\section{Testando o ambiente}
Antes de se começar a programação, é aconselhável que o usuário coloque em 
funcionamento  o \emph{demo} Hello que acompanha o pacote. O correto funcionamento 
do \emph{demo}, elimina uma série de possíveis problemas que o desenvolvedor possa 
enfrentar durante o seu projeto, como por exemplo: problemas de comunicação 
com o barramento, mecanismo de interceptação não habilitado e ausência de 
bibliotecas dinâmicas externas.
Naturalmente a execução do \emph{demo} necessita de um barramento em operação. 
O \emph{demo} pode ser executado seguindo os seguintes passos:

\begin{enumerate}
  \item Definir a variável de ambiente \lstinline!OPENBUS_HOME! como o caminho absoluto da instalação 
  do pacote Openbus SDK C++.
  \item Definir a variável de ambiente \lstinline!TEC_UNAME! com o identificador da plataforma, que é a 
  última sequência de caracteres após o último hífen do nome do pacote, por exemplo: Linux26, 
  SunOS510 ou Linux26g4.
  \item Disponibilizar na variável de ambiente  \lstinline!LD_LIBRARY_PATH! o caminho 
   \lstinline!$OPENBUS_HOME/libpath/$TEC_UNAME!.
  \item Entrar no diretório \lstinline!demo/hello/orbix! ou \lstinline!demo/hello/mico!, que 
  está disponível na árvore do pacote. 
  \item Gerar uma chave privada e um certificado digital com os respectivos nomes: 
  \lstinline!HelloService.key! e \lstinline!HelloService.crt!. O segundo arquivo deve ser colocado
   na pasta \lstinline!certificates! do barramento, e, o certificado  
   \lstinline!AccessControlService.crt! deve   ser obtido junto ao administrador do barramento e
   colocado na pasta atual, em conjunto  da chave privada HelloService.key.
   \href{https://jira.tecgraf.puc-rio.br/confluence/display/ESDPUB/Geracao+de+Chaves+e+Certificados+Digitais} {Geracao de Chaves e Certificados Digitais}
  \item Editar o arquivo \lstinline!democonfig! e configurar a localização do barramento.
  \item Executar o processo servidor: \lstinline!./runserver!

  A mensagem "Servico IHello registrado." deve ser retornada.
  \item Executar o processo cliente: \lstinline!./runclient!

  Após a execução do cliente, no terminal do processo servidor a seguinte 
  mensagem deve ser retornada: "Servant diz: HELLO!".
\end{enumerate}

Aconselha-se que o primeiro teste seja feito com o processo servidor e 
cliente na mesma máquina. O arquivo democonfig apresenta por padrão as 
configurações para este tipo de teste.
É interessante que este teste também seja realizado, se possível, utilizando-se
as máquinas finais que serão utilizadas no projeto do desenvolvedor. Problemas
de comunicação podem ocorrer por conta das configurações de rede das máquinas 
envolvidas. 

\section{Desenvolvimento}
\subsection{API}
\lstset{language=c++}
O serviço de acesso ao barramento é utilizado através de uma API proprietária,
que é representada pelo arquivo \lstinline!openbus.h!, no entanto o serviço de 
registro é acessado diretamente através de um stub previamente disponibilizado. No caso do Mico a API para o serviço de registro
é descrita através do arquivo \lstinline!stubs/mico/registry_service.h!.
Quanto ao Orbix, o serviço de registro é representado por 
\lstinline!stubs/orbix/registry_service.hh!.

\subsubsection{openbus.h}

\begin{lstlisting}
  static Openbus::getInstance()
\end{lstlisting}

Fornece a única instância do barramento.

\begin{lstlisting}
  void Openbus::init(
  int argc,
  char** argv)
\end{lstlisting}

Inicializa uma referência a um barramento.

Um ORB e um POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Os argumentos Openbus de linha de comando (argc e argv) são tratados.
Parâmetros de linha de comando: 
\begin{description}
  \item[-OpenbusHost]  Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-OpenbusDebug]
    ALL - Ativa todos os níveis de verbose.
    ERROR - Ativa o nível ERROR do debug.
    INFO - Ativa o nível INFO do debug.
    WARNING - Ativa o nível WARNING do debug.
  \item[-OpenbusDebugFile] Caminho completo ou relativo do arquivo que armazenará as  mensagens 
    de verbose. Se este parâmetro não for definido, a saída do verbose será a saída padrão.
    OBS.:  Se for  definido, o  verbose  somente  será armazenado  no  arquivo  em questão, 
    ou seja, a saída padrão não será mais utilizada.
  \item[-OpenbusValidationPolicy] Define uma política de validação das credenciais. Por padrão, 
    a política ALWAYS é adotada.
    NONE: Não há validação de credenciais.
    ALWAYS: Sempre valida cada credencial no ACS.
    CACHED: Primeiro  tenta  validar  a   credencial    consultando    um    cache   local, 
      se não conseguir, a validação  transcorre normalmente através de  uma  chamada remota 
      ao ACS.
  \item[-OpenbusValidationTime] Define o intervalo de tempo(em milisegundos)   de  validação do 
    cache de credenciais. O tempo padrão é de 30000ms.
  \item[-OpenbusFTConfigFilename] Caminho completo  ou  relativo  do  arquivo  que  descreve as 
    réplicas a serem utilizadas pelo mecanismo de tolerância a falhas.
  \item[-OpenbusTimeRenewing] Tempo em segundos de renovação da credencial.
  \end{description}

\begin{lstlisting}
  void Openbus::init(
    int argc,
    char** argv,
    char* host,
    unsigned short port)
\end{lstlisting}


Inicializa uma referência a um barramento.

Um ORB e um POA são criados implicitamente.
A fábrica de componentes SCS é criada.
Os argumentos Openbus de linha de comando (argc e argv) são tratados.
Parâmetros de linha de comando: 
\begin{description}
  \item[-OpenbusHost]  Máquina em que se encontra o barramento.
  \item[-OpenbusPort] Porta do barramento.
  \item[-OpenbusDebug]
    ALL - Ativa todos os níveis de verbose.
    ERROR - Ativa o nível ERROR do debug.
    INFO - Ativa o nível INFO do debug.
    WARNING - Ativa o nível WARNING do debug.
  \item[-OpenbusDebugFile] Caminho completo ou relativo do arquivo que armazenará as  mensagens 
    de verbose. Se este parâmetro não for definido, a saída do verbose será a saída padrão.
    OBS.:  Se for  definido, o  verbose  somente  será armazenado  no  arquivo  em questão, 
    ou seja, a saída padrão não será mais utilizada.
  \item[-OpenbusValidationPolicy] Define uma política de validação das credenciais. Por padrão, 
    a política ALWAYS é adotada.
    NONE: Não há validação de credenciais.
    ALWAYS: Sempre valida cada credencial no ACS.
    CACHED: Primeiro  tenta  validar  a   credencial    consultando    um    cache   local, 
      se não conseguir, a validação  transcorre normalmente através de  uma  chamada remota 
      ao ACS.
  \item[-OpenbusValidationTime] Define o intervalo de tempo(em milisegundos)   de  validação do 
    cache de credenciais. O tempo padrão é de 30000ms.
  \item[-OpenbusFTConfigFilename] Caminho completo  ou  relativo  do  arquivo  que  descreve as 
    réplicas a serem utilizadas pelo mecanismo de tolerância a falhas.
  \item[-OpenbusTimeRenewing] Tempo em segundos de renovação da credencial.
\end{description}

\begin{lstlisting}
  bool Openbus::isConnected()
\end{lstlisting}

Informa o estado de conexão com o barramento.

\begin{lstlisting}
  static void Openbus::terminationHandlerCallback(long signalType)
\end{lstlisting}

Disponibiliza um \lstinline!termination handler! que desconecta o usuário do barramento e finaliza a 
execução do Openbus::run().

Essa callback pode ser utlizada em uma implementação de um \lstinline!termination handler! a ser es-
crito pelo usuário. No caso do Orbix, o método pode ser registrado diretamente na   classe
\lstinline!IT_TerminationHandler()!, e.g.:

\lstinline!IT_TerminationHandler termination_handler(openbus::Openbus::terminationHandlerCallback)!

O método desconecta o usuário do barramento,   se   este   estiver  conectado,  executa um
\lstinline!Openbus::stop()!  seguido  por  um  \lstinline!Openbus::finish()!,  e,  por  último  faz   delete  da instanciação do Openbus.

\begin{lstlisting}
  CORBA::ORB* Openbus::getORB()
\end{lstlisting}

Retorna o ORB utilizado.

\begin{lstlisting}
  PortableServer::POA* getRootPOA();
\end{lstlisting}

Retorna o RootPOA.

\begin{lstlisting}
  scs::core::ComponentBuilder* Openbus::getComponentBuilder()
\end{lstlisting}

Retorna a fábrica de componentes.

\begin{lstlisting}
  Credential_var Openbus::getInterceptedCredential()
\end{lstlisting}

Retorna a credencial interceptada pelo interceptador servidor. 
!Atenção! Esta operação somente deve ser chamada durante o processo de 
tratamento de requisição do serviço implementado.  

\begin{lstlisting}
  openbusidl::acs::IAccessControlService* Openbus::getAccessControlService()
\end{lstlisting}

Retorna o serviço de acesso.

\begin{lstlisting}
  registry_service::IRegistryService* getRegistryService(); 
\end{lstlisting}

Retorna o serviço de registro.

\begin{lstlisting}
  access_control_service::Credential* Openbus::getCredential()
\end{lstlisting}

Retorna a credencial de identificação do usuário frente ao barramento.

\begin{lstlisting}
  void setThreadCredential(access_control_service::Credential* credential)
\end{lstlisting}

Define uma credencial a ser utilizada no lugar da credencial corrente.
Útil para fornecer uma credencial com o campo delegate preenchido.
!Atenção! Nesta versão este método não considera um comportamento multithread, 
 sendo assim a alteração de credencial será válida para todas as threads.

\begin{lstlisting}
  class LeaseExpiredCallback {
    public:
      virtual void expired() = 0;
  };
\end{lstlisting}

Representa uma callback para a notificação de que o lease da credencial de 
indentificação do usuário expirou. O usuário deve fornecer a implementação 
da callback implementando o método expired().
\begin{lstlisting}
  void setLeaseExpiredCallback(LeaseExpiredCallback* leaseExpiredCallback)
\end{lstlisting}

Registra uma callback para a notificação de lease expirado através de um 
objeto do tipo LeaseExpiredCallback. Este método deve ser chamado após o 
estabelecimento da conexão com o barramento.

\begin{lstlisting}
  void removeLeaseExpiredCallback()
\end{lstlisting}

Remove uma callback previamente registrada para a notificação de lease 
expirado.Este método deve ser chamado após o estabelecimento da conexão 
com o barramento.

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* user,
    const char* password)
    throw (CORBA::SystemException, LOGIN_FAILURE)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com o barramento 
  ocorreu.
  Possíveis causas:
  \begin{itemize}
    \item Os valores que definem a localização do barramento(host e porta) 
    estão incorretos.
    \item O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  \end{itemize}
\end{description}

\begin{lstlisting}
  services::RegistryService* Openbus::connect(
    const char* entity,
    const char* privateKeyFilename,
    const char* ACSCertificateFilename)
    throw (CORBA::SystemException, LOGIN_FAILURE, SECURITY_EXCEPTION)
\end{lstlisting}

Realiza uma tentativa de conexão com o barramento utilizando o mecanismo de 
certificação para o processo de autenticação. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

\begin{description}
  \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
  \item[CORBA::SystemException] Alguma falha de comunicação com obarramento 
  ocorreu. Possíveis causas:
  Os valores que definem a localização do barramento(host e porta) estão 
  incorretos.
  O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
  \item[SECURITY\_EXCEPTION] Falha no mecanismo de autenticação por certificado 
  digital. Algumas possíveis causas:

  Não foi possível obter o desafio.
  Falha na manipulação de uma chave privada ou pública.
  Falha na manipulação de um certificado.
\end{description}

\begin{lstlisting}
  bool Openbus::disconnect()
\end{lstlisting}

Desfaz a conexão atual. Caso a conexão seja desfeita, true é retornado, caso 
contrário, o valor de retorno é false.

\begin{lstlisting}
  void Openbus::run()
\end{lstlisting}

Loop que processa requisições CORBA.
!Atenção! Este método na versão Mico *multi thread* faz um wait() na RunThread.

\begin{lstlisting}
  void stop()
\end{lstlisting}

Pára de processar requisições CORBA. Finaliza a execução do run.
!Atenção! Não faz nada na versão Mico *multi thread*.

\begin{lstlisting}
  void finish(bool force);
\end{lstlisting}

Finaliza a execução do ORB.

\begin{lstlisting}
  void setInterceptable(
    string interfaceRepID, 
    string method, 
    bool isInterceptable)
\end{lstlisting}

Define se os métodos de uma determinada interface devem ou não ser interceptados pelo
interceptador servidor.

\begin{lstlisting}
  bool isInterceptable(
    string interfaceRepID, 
    string method)
\end{lstlisting}

Consulta se o método está sendo interceptado.

\begin{lstlisting}
  bool isFaultToleranceEnable()
\end{lstlisting}

Consulta se o mecanismo de tolerancia a falhas está ativado.

\subsection{Tolerância a falhas}

O usuário Orbix pode habilitar um mecanismo de tolerância a falhas em requisições 
remotas destinadas aos serviços básicos do barramento. Para isto, é necessário 
ter em mãos a lista de réplicas disponíveis para o serviço de acesso, e, descrevê-las 
em um arquivo do tipo Lua. Um exemplo:

\lstset{language=bash}
\begin{lstlisting}
-- replicas.lua
ACSHosts = {
  {"nomeMaquinaA", 2089},
  {"nomeMaquinaB", 4089},
}
\end{lstlisting}

Essas informações devem ser obtidas com o administrador do barramento. A habilitação 
do mecanismo é através do parâmetro de linha de comando \lstinline!-OpenbusFTConfigFilename!, 
que deve receber o caminho relativo ou absoluto do arquivo acima.

\subsection{Primeiros passos...}
Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e 
outra que consome serviços. Sendo possível e natural uma aplicação híbrida 
que tanto oferte quanto consuma. Para ambos os tipos, existe uma certa 
dinâmica de programação já definida. E é justamente a explicitação dessa 
dinâmica que será o objetivo deste tópico. 
Como facilitador, os processos serão demonstrados com base no \emph{demo} Hello. 
De propósito, este é um \emph{demo} muito simplório, que é composto de um módulo 
cliente e de outro servidor. O servidor oferta um serviço do tipo Hello 
num determinado barramento, já o cliente procura por este serviço no 
barramento e o utiliza.

\subsection{Conexão com o barramento}
O primeiro passo é firmar uma conexão autenticada com o barramento, o que é 
necessário tanto para o cliente como para o servidor. Para se concluir a 
conexão é preciso:
\begin{enumerate}
  \item Adquirir a instância que representa o barramento
  \begin{lstlisting}
  openbus::Openbus* bus = Openbus::getInstance();
  \end{lstlisting}
  \item Inicializar essa referência bus:
  \begin{lstlisting}
  bus->init(argc, argv);
  \end{lstlisting}
  \item Efetuar uma autenticação no barramento através do certificado do 
  serviço:
  \begin{lstlisting}
  services::RegistryService* registryService =
    bus->connect(
      "HelloService", 
      "HelloService.key",
      "AccessControlService.crt");
  \end{lstlisting}
\end{enumerate}

Existem dois modos de autenticação frente ao barramento:

\begin{enumerate}
  \item Par usuário e senha.
  \item Certificado digital.
\end{enumerate}

O primeiro é destinado normalmente aos clientes que estão acessando o 
barramento a procura de um serviço, já o segundo é mais adequado ao processo 
servidor que estará registrando um determinado serviço no barramento.
O responsável pelo serviço deve encaminhar ao administrador do barramento o 
certificado do serviço, ou seja, um arquivo especial que contenha a chave 
pública do serviço, dentre outras informações pertinentes. O administrador 
deve fornecer o certificado do serviço de controle de acesso. 

\subsection{Registro de serviço}

Um serviço pode ser colocado no barramento através de uma oferta de 
serviço (ServiceOffer), que é uma estrutura que representa o serviço através 
de uma lista de propriedades (properties) e de uma referência para um 
componente (member) SCS. 


\begin{lstlisting}
typedef sequence<string> PropertyValue;
struct Property {
    string name;
    PropertyValue value;
};

typedef sequence<Property> PropertyList;

struct ServiceOffer {
    PropertyList properties;
    scs::core::IComponent member;
};
\end{lstlisting}

Através da lista de propriedades, é possível caracterizar o serviço. 
A arquitetura do Openbus é baseada no modelo de componentes SCS. O 
serviço é de fato representado por um componente, que pode apresentar 
distintas facetas (interfaces). Sendo assim, o primeiro passo para o 
registro de um serviço, é criar um componente que represente o serviço 
desejado. 
Uma fábrica de componentes (componentBuilder) pode ser adquirida 
através do método \emph{Openbus::getComponentBuilder()}.  
De posse desta fábrica, o usuário pode criar um componente pendurando uma 
ou mais facetas:

\begin{lstlisting}
/* Fabrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definicao do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descricao das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);
\end{lstlisting}

O serviço a ser registrado no barramento deve ser descrito através de uma 
oferta de serviço, que é representada pela estrutura ServiceOffer. 
Pendura-se nesta estrutura o serviço em si, que é representado através de 
um componente SCS, e, opcionalmente uma lista de propriedades referentes ao 
serviço.
As propriedades devem ser descritas numa estrutura que represente uma lista 
de propriedades. Como esta lista é uma sequence de uma estrutura que possui 
uma outra lista, que é justamente a lista de valores, pois uma chave pode 
estar relacionada a mais de um valor, o preenchimento dos valores desejados 
envolve um número de linhas de código um tanto indesejável. Por este motivo, 
há a classe de auxílio PropertyListHelper que tem por objetivo facilitar o 
trabalho de construção das listas de propriedades.
Por exemplo, se o usuário desejar criar uma lista que contenha somente uma 
propriedade do tipo chave/valor, o mesmo deveria entrar com algo do tipo:

\begin{lstlisting}
openbusidl::rs::PropertyList_var p = new openbusidl::rs::PropertyList(1);
  p->length(1);
  openbusidl::rs::Property_var property = new openbusidl::rs::Property;
  property->name = "description";
  openbusidl::rs::PropertyValue_var propertyValue = 
    new openbusidl::rs::PropertyValue(1);

  propertyValue->length(1);
  propertyValue[0] = "Serviço IHello";
  property->value = propertyValue;
  p[0] = property;
\end{lstlisting}

Agora, se a classe de auxílio for utilizada, reduzimos este código para:

\begin{lstlisting}
  openbus::util::PropertyListHelper* propertyListHelper = \
    new openbus::util::PropertyListHelper();

/* Criacao de uma *oferta de servico*. */
  registry_service::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;
\end{lstlisting}

De posse da lista de propriedades e do componente que representa o serviço, 
é possível requisitar o registro do serviço:

\begin{lstlisting}
registryId = registryService->_cxx_register(serviceOffer);
\end{lstlisting}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou 
o serviço. O último passo necessário para se finalizar o código do servidor é 
habilitar o processo servidor a escutar as requisições CORBA que serão 
direcionadas para o serviço ofertado:

\begin{lstlisting}
bus->run();
\end{lstlisting}

\subsection{Processo cliente}

Como o servidor, o cliente necessita se autenticar no barramento, portanto, 
os mesmos passos aplicados no servidor para a autenticação devem ser 
repetidos, com exceção de que o cliente se autentica através do mecanismo 
usuário e senha:

\begin{lstlisting}
  registryService = bus->connect("tester", "tester");
\end{lstlisting}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o 
serviço desejado. Isso pode ser feito através de uma chamada ao método 
services::RegistryService::find(), que retorna uma lista de ofertas de 
serviço que implementam a faceta que o usuário deseja.

Busca do serviço:

\begin{lstlisting}
/* Define a lista de facetas que caracteriza o serviço implementa.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::util::FacetListHelper* facetListHelper =
    new openbus::util::FacetListHelper();
  facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  registry_service::ServiceOfferList_var serviceOfferList =
    registryService->find(facetListHelper->getFacetList());
  delete facetListHelper;

  registry_service::ServiceOffer serviceOffer = serviceOfferList[(CORBA::ULong) 0];
\end{lstlisting}

Como visto acima, a oferta de serviço armazena o serviço através de um 
componente SCS. Como este componente pode apresentar diversas facetas, 
o usuário deve informar qual faceta deseja utilizar. No exemplo utilizado, 
somente há uma faceta, que é a IHello. O componente oferece um 
método(getFacet) para que o usuário possa obter um objeto CORBA que 
represente o serviço desejado:

\begin{lstlisting}
scs::core::IComponent_var component = serviceOffer.member;
CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
\end{lstlisting}

De posse do objeto CORBA, o usuário deve efetuar um narrow para mapeá-lo para 
a interface desejada:

\begin{lstlisting}
demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);
\end{lstlisting}

Daqui em diante o programador estará apto a utilizar o serviço.

\clearpage
\subsection{Código servidor}

\begin{lstlisting}
/*
** OpenBus Demo - Mico
** server.cpp
*/

#include <fstream>
#include <iostream>
#include <CORBA.h>
#include <csignal>

#include <openbus.h>
#include <ComponentBuilder.h>

#include "stubs/hello.h"

using namespace std;
using namespace tecgraf::openbus::core::v1_05;
using namespace tecgraf::openbus::core::v1_05::registry_service;

openbus::Openbus* bus;
registry_service::IRegistryService* registryService = 0;
char* registryId;
scs::core::ComponentContext* componentContext;

class HelloImpl : virtual public POA_demoidl::hello::IHello {
  private:
    scs::core::ComponentContext* componentContext;
    HelloImpl(scs::core::ComponentContext* componentContext) {
      this->componentContext = componentContext;
    }
  public:
    static PortableServer::ServantBase* instantiate(
      scs::core::ComponentContext* componentContext) 
    {
      return (PortableServer::ServantBase*) new HelloImpl(componentContext);
    }
    static void destruct(void* obj) {
      delete (HelloImpl*) obj;
    }
    void sayHello() throw(CORBA::SystemException) {
      cout << "Servant diz: HELLO!" << endl;
      access_control_service::Credential_var credential = 
        bus->getInterceptedCredential();
      cout << "Usuario OpenBus que fez a chamada: " << credential->owner.in()
        << endl;
    };
};

void termination_handler(int p) {
  cout << "Encerrando o processo servidor..." << endl;
  if (registryService) {
    try {
      registryService->unregister(registryId);
      registryService = 0;
    } catch(CORBA::Exception& e) {
      cout << "Nao foi possivel remover a oferta de servico." << endl;
    }
  }
  openbus::Openbus::terminationHandlerCallback((long) signal);
}

int main(int argc, char* argv[]) {
  signal(SIGINT, termination_handler);
  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexao com o barramento atraves de certificado. */
  try {
    registryService = bus->connect("HelloService", "HelloService.key",
      "AccessControlService.crt");
  } catch (CORBA::SystemException& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Falha na comunicacao. *" << endl;
    exit(1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Par usuario/senha invalido. *" << endl;
    exit(1);
  } catch (openbus::SECURITY_EXCEPTION& e) {
    cout << e.what() << endl;
    exit(1);
  }

  cout << "Conexao com o barramento estabelecida com sucesso!" << endl;

/* Fabrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

/* Definicao do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

/* Descricao das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);

  openbus::util::PropertyListHelper* propertyListHelper = \
    new openbus::util::PropertyListHelper();

/* Criacao de uma *oferta de servico*. */
  registry_service::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;

  cout << "Registrando servico IHello no barramento..." << endl;

/* Registro do servico no barramento. */
  try {
    if (registryService) {
      registryId = registryService->_cxx_register(serviceOffer);
    } else {
      cout << "Nao foi possivel adquirir um proxy para o servico de registro." 
        << endl;
      exit(1);
    }
  } catch (UnathorizedFacets& e) {
    cout << "Nao foi possivel registrar IHello." << endl;
    CORBA::ULong idx;
    CORBA::ULong length = e.facets.length();
    for (idx = 0; idx < length; idx++) {
      cout << "Faceta nao autorizada: " << e.facets[idx] << endl;
    }
    exit(1);
  }
  cout << "Servico IHello registrado." << endl;
  cout << "Aguardando requisicoes..." << endl;

  bus->run();

  return 0;
}

\end{lstlisting}

\clearpage
\subsection{Código cliente}

\begin{lstlisting}
/*
** OpenBus Demo - Mico
** client.cpp
*/

#include <fstream>
#include <iostream>

#include "stubs/hello.h"
#include <openbus.h>

using namespace std;
using namespace tecgraf::openbus::core::v1_05;

int main(int argc, char* argv[]) {
  openbus::Openbus* bus;
  registry_service::IRegistryService* registryService;

  bus = openbus::Openbus::getInstance();

  bus->init(argc, argv);

  cout << "Conectando no barramento..." << endl;

/* Conexão com o barramento. */
  try {
    registryService = bus->connect("tester", "tester");
  } catch (CORBA::SystemException& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Falha na comunicacao. *" << endl;
    exit(-1);
  } catch (openbus::LOGIN_FAILURE& e) {
    cout << "** Nao foi possivel se conectar ao barramento. **" << endl \
         << "* Par usuario/senha inválido. *" << endl;
    exit(-1);
  }

  cout << "Conexão com o barramento estabelecida com sucesso!" << endl;

/* Define a lista de facetas que caracteriza o serviço implementa.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
  openbus::util::FacetListHelper* facetListHelper =
    new openbus::util::FacetListHelper();
  facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
  registry_service::ServiceOfferList_var serviceOfferList =
    registryService->find(facetListHelper->getFacetList());
  delete facetListHelper;

  if (serviceOfferList->length() > 0) {
    registry_service::ServiceOffer serviceOffer = serviceOfferList[(CORBA::ULong) 0];
  
    scs::core::IComponent_var component = serviceOffer.member;
    CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
    demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);

    cout << "Fazendo chamada remota sayHello()..." << endl;

    hello->sayHello();
  } else {
    cout << "Nenhuma oferta encontrada." << endl;
  }
  
  cout << "Desconectando-se do barramento..." << endl;

  bus->disconnect();
  delete bus;

  return 0;
}

\end{lstlisting}

\end{document}

