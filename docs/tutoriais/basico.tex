\documentclass[12pt]{article}

%% Estilos e Plug-Ins
\usepackage{a4}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{color}
\usepackage{epsfig}
\usepackage{mwlabinputs}
\usepackage{hyperref}

\setlength{\parskip}{6mm}
\textheight=8.2in

%% Redefines the label 'Listing' to ..
\def\lstlistingname{Código}
\lstset{inputencoding=latin1}
\codestyle{colorful}
%% Removes hyperlinks borders
\hypersetup{
  pdfborder = {0 0 0},
}

\newcommand{\code}[1]{\texttt{#1}}

% ===================
% Inicio do documento
% ===================

\lstset{
  language = c++, 
  breaklines = true,
  breakatwhitespace = true,
  showlines = true
}

\begin{document}
\title{OpenBus-C++ - Tutorial - API}
\author{R. Cosme \\
        Tecgraf \\
        Pontifícia Universidade Católica do Rio de Janeiro 
        (PUC-Rio)\\
        openbus-dev@tecgraf.puc-rio.br}

\date{\today}
\maketitle


\pagenumbering{arabic}

\section{Introdução}
Este documento tem por objetivo servir como ponto de partida para os usuários desenvolvedores de aplicações C++ que estão interessados em programar utilizando o Openbus. O processo de \emph{deployment} do barramento não é coberto aqui neste tutorial. Considera-se como pré-requisitos para um bom entendimento deste texto um conhecimento básico dos seguintes assuntos:

\begin{itemize}
  \item Linguagem de programação C++.
  \item CORBA.
  \item Modelo de Componentes SCS.
  \item Conceitos básicos do Openbus.
\end{itemize}

Maiores informações podem ser obtidas em:
http://www.tecgraf.puc-rio.br/openbus

\section{Preparação do Ambiente}
O Openbus C++ suporta os ORB`s Mico 2.3.13 e Orbix 6.3 Service Pack 3. O usuário Mico pode escolher entre 
a versão singlethread ou multithread. Abaixo explicamos o que deveria ser feito na configuração 
destes ORB`s para que o usuário possa utilizar o Openbus. Assumimos que o usuário tenha adquirido 
o ORB através de um pacote Openbus SDK C++ obtido em nosso site.

\subsection {Mico 2.3.13} 

Para que se possa utilizar o Mico, deveria somente ser necessário carregar no shell do usuário 
o arquivo de configuração \lstinline!mico-setup.sh!, para usuários que usam *bash* ou \lstinline!mico-setup.csh! para usuários que usam *csh*. Este script pode ser encontrado no diretório \lstinline!specs/shell! da instalação do pacote. O usuário que já tem o Mico instalado, deve verificar se este arquivo está sendo carregado no seu ambiente. Este script fica localizado 
na pasta \lstinline!lib! da instalação do Mico. Atenção, não recomendamos a utilização de um Mico 
que não aquele fornecido em nosso pacote. Mantemos algumas alterações proprietárias do Mico que são necessárias para o correto funcionamento de todas as funcionalidades ofertadas pela API Openbus C++.
 
\subsection {Orbix 6.3 sp3}
No Orbix o usuário precisa habilitar o mecanismo de interceptação de CORBA, pois o mesmo não está habilitado 
por padrão. O Openbus utiliza este recurso no processo de controle de acesso aos serviços. O usuário também precisa carregar um script de configuração do ambiente no seu shell.
 
Este ORB é configurável através de domínios de configuração que por sua vez 
formam um ambiente. O domínio é formado por escopos que são representados através 
de um arquivo textual que pode ser editado diretamente pelo administrador. 
Não vamos abordar aqui como criar um domínio, para tal o usuário deve consultar a documentação 
do Orbix.

Considerando-se que o usuário tenha o seu domínio, as linhas apresentadas no
código~\ref{lst:dominio} devem ser adicionadas no arquivo de configuração do
domínio:

\begin{labeledcode}[bash]{dominio}{Código a ser adicionado no arquivo de configuração do domínio}
  openbus {
    policies:giop:interop_policy:ignore_message_not_consumed = "true";
    orb_plugins = [
      "local_log_stream", 
      "iiop_profile", 
      "giop", 
      "iiop", 
      "portable_interceptor"
    ];
    binding:server_binding_list = [
      "OTS+AccessControl", 
      "AccessControl", 
      "OTS", 
      ""
    ];
    binding:client_binding_list = [
      "AccessControl+OTS+POA_Coloc", 
      "AccessControl+POA_Coloc", 
      "OTS+POA_Coloc", 
      "POA_Coloc", 
      "AccessControl+OTS+GIOP+IIOP", 
      "AccessControl+GIOP+IIOP", 
      "OTS+GIOP+IIOP", 
      "GIOP+IIOP"
    ];
  };
};
\end{labeledcode}

As quatro diretivas necessárias para o correto funcionamento do Openbus são 
definidas no escopo \lstinline!tecgraf.openbus!. A primeira define uma política necessária para que IIOP.NET possa se comunicar com o Openbus Orbix. A segunda carrega 
o plugin responsável pelo mecanismo de interceptação. As duas últimas registram 
o interceptador (\lstinline!AccessControl!).
  
Por último, o usuário deve se certificar que o script shell que configura o domínio a ser 
utilizado foi carregado. Este arquivo é gerado como resultado do processo de configuração.

\section{Testando o ambiente}
Antes de se começar a programação, é aconselhável que o usuário coloque em 
funcionamento  a \emph{demo} Hello que acompanha o pacote. O pacote inclui a demo já 
compilada para uma plataforma em específico. O correto funcionamento 
da \emph{demo} elimina possíveis problemas que o desenvolvedor possa 
enfrentar durante o seu projeto, como por exemplo: falhas de comunicação 
com o barramento, mecanismo de interceptação não habilitado e ausência de 
bibliotecas dinâmicas externas.
Naturalmente a execução da \emph{demo} necessita de um barramento em operação. 
A \emph{demo} pode ser executada seguindo os seguintes passos:

\begin{enumerate}
  \item Definir a variável de ambiente \emph{OPENBUS\_HOME} como o caminho absoluto da instalação do pacote Openbus SDK C++.
  \item Definir a variável de ambiente \emph{TEC\_UNAME} com o identificador da plataforma, que é a 
  última sequência de caracteres após o último hífen do nome do pacote, por exemplo: Linux26, SunOS510 ou Linux26g4.
  \item Disponibilizar na variável de ambiente \emph{LD\_LIBRARY\_PATH} o caminho 
\emph{\$OPENBUS\_HOME/libpath/\$TEC\_UNAME}.
  \item Entrar no diretório \emph{demo/hello/orbix} ou \emph{demo/hello/mico}, que está disponível na árvore do pacote. 
  \item Gerar uma chave privada e um certificado digital. Os arquivos devem ser disponibilizados no 
   diretório da demo. O arquivo referente ao certificado deve ser colocado
   na pasta \emph{certificates} do barramento, e o certificado referente ao serviço de acesso 
   deve   ser obtido junto ao administrador do barramento e
   colocado na pasta atual, em conjunto  da chave privada que foi gerada.
   \href{https://jira.tecgraf.puc-rio.br/confluence/display/ESDPUB/Geracao+de+Chaves+e+Certificados+Digitais} {Geracao de Chaves e Certificados Digitais}
  \item Editar o arquivo \emph{democonfig} e configurar a localização do barramento como também o nome 
  da chave privada e do certificado do serviço de controle de acesso.
  \item Executar o processo servidor: \emph{./runserver}

  A mensagem ``Servico IHello registrado." deve ser retornada.
  \item Executar o processo cliente: \emph{./runclient}

  Após a execução do cliente, no terminal do processo servidor a seguinte 
  mensagem deve ser retornada: ``Servant diz: HELLO!".
\end{enumerate}

Aconselha-se que o primeiro teste seja feito com o processo servidor e 
cliente na mesma máquina. O arquivo democonfig apresenta por padrão as 
configurações para este tipo de teste.
É interessante que este teste também seja realizado, se possível, utilizando-se
as máquinas finais que serão utilizadas no projeto do desenvolvedor. Problemas
de comunicação podem ocorrer por conta das configurações de rede das máquinas 
envolvidas. 

\section{Desenvolvimento}
\subsection{Compilação}
As demos disponibilizadas no pacote possuem um arquivo Makefile (GNU) para compilação.
Este arquivo pode e deve ser utilizado como ponto de partida para as modificações 
necessárias a serem realizadas no processo de compilação do projeto do usuário. 
Neste quesito existem algumas particularidades entre o uso Orbix e Mico.
\subsubsection{Mico}
O projeto do usuário deve utilizar as seguintes bibliotecas:
\begin{description}
    \item[openbusmico] Biblioteca Openbus para Mico.
    \item[scsmico] Biblioteca SCS para Mico.
    \item[logger] Biblioteca de logging.
\end{description}
As bibliotecas acima requerem: \emph{dl, crypto, ssl, lua5.1 e pthread} (no caso de uso de uma versão multithread).
O Openbus SDK C++ Mico permite a escolha entre uso singlethread ou multithread, 
como também 32 ou 64bits. Estas duas configurações podem ser definidas através 
das macros \emph{MULTITHREAD} e \emph{MICO\_64}.
\subsubsection{Orbix}
O projeto deve ser compilado utilizando as seguintes bibliotecas:
\begin{description}
    \item[openbusorbix] Biblioteca Openbus para Orbix.
    \item[scsorbix] Biblioteca SCS para Mico.
    \item[logger] Biblioteca de logging.
\end{description}
As bibliotecas acima requerem: \emph{it\_poa, it\_art, it\_ifc, it\_portable\_interceptor, dl, crypto ssl e lua5.1}.
É necessário que o usuário defina as seguintes macros: \emph{SCS\_ORBIX} e \emph{OPENBUS\_ORBIX}.
Estas macros são necessárias para habilitar o código referente ao uso com Orbix, pois por padrão 
o Openbus SDK C++ espera o uso do Mico.
\subsection{API}
\lstset{language=c++}
A API C++ do Openbus é representada pelo arquivo \emph{openbus.h} e pelo 
stub do serviço de registro, que no caso do Mico é o arquivo 
\emph{stubs/mico/registry\_service.h} e no Orbix o arquivo 
\emph{stubs/orbix/registry\_service.hh}. A documentação da API também está 
presente na forma de comentários nos arquivos citados acima.

\subsubsection{openbus.h}

\begin{itemize}
  \item \code{static Openbus::getInstance()}: Fornece a única instância do barramento.
  
  \item \code{void Openbus::init(int argc, char** argv, char* host, unsigned short port)} \\ 
  \code{void Openbus::init(int argc, char** argv)}: Inicializa uma referência a um barramento.

Um ORB e um POA são criados implicitamente. A fábrica de componentes SCS é criada. Os argumentos Openbus de linha de comando (argc e argv) são tratados. Parâmetros de linha de comando: 
  \begin{description}
    \item[-OpenbusHost] Máquina em que se encontra o barramento.
    \item[-OpenbusPort] Porta do barramento.
    \item[-OpenbusDebug] 
      ALL - Ativa todos os níveis de verbose.
      ERROR - Ativa o nível ERROR do debug.
      INFO - Ativa o nível INFO do debug.
      WARNING - Ativa o nível WARNING do debug.
    \item[-OpenbusDebugFile] Caminho completo ou relativo do arquivo que armazenará as mensagens de verbose. Se este parâmetro não for definido, a saída do verbose será a saída padrão. OBS.:  Se for  definido, o  verbose somente  será armazenado no arquivo em questão, ou seja, a saída padrão não será mais utilizada.
    \item[-OpenbusValidationPolicy] Define uma política de validação das credenciais. Por padrão, a política ALWAYS é adotada.
      NONE: Não há validação de credenciais.
      ALWAYS: Sempre valida cada credencial no ACS.
      CACHED: Primeiro tenta validar a credencial consultando um cache local, se não conseguir, a validação transcorre normalmente através de uma chamada remota ao ACS.
    \item[-OpenbusValidationTime] Define o intervalo de tempo(em milisegundos)   de validação do cache de credenciais. O tempo padrão é de 30000ms.
    \item[-OpenbusFTConfigFilename] Caminho completo ou relativo do arquivo que descreve as réplicas a serem utilizadas pelo mecanismo de tolerância a falhas.
    \item[-OpenbusTimeRenewing] Tempo em segundos de renovação da credencial.
  \end{description}

  \item \code{bool Openbus::isConnected()}: Informa o estado de conexão com o barramento.

  \item \code{static void Openbus::terminationHandlerCallback(long signalType)}: Disponibiliza um \emph{termination handler} que desconecta o usuário do barramento e finaliza a execução do \code{Openbus::run()}.

Essa callback pode ser utlizada em uma implementação de um \emph{termination handler} a ser escrito pelo usuário. No caso do Orbix, o método pode ser registrado diretamente na classe \code{IT\_TerminationHandler()}, e.g.:

\code{IT\_TerminationHandler termination\_handler(\\ openbus::Openbus::terminationHandlerCallback)}

O método desconecta o usuário do barramento, se este estiver conectado, executa um \emph{Openbus::stop()} seguido por um \emph{Openbus::finish()}, e, por último  faz delete da instanciação do Openbus.

  \item \code{CORBA::ORB* Openbus::getORB()}: Retorna o ORB utilizado.

  \item \code{PortableServer::POA* getRootPOA()}: Retorna o RootPOA.

  \item \code{scs::core::ComponentBuilder* Openbus::getComponentBuilder()}: Retorna a fábrica de componentes.

  \item \code{Credential\_var Openbus::getInterceptedCredential()}: Retorna a credencial interceptada pelo interceptador servidor. \textbf{Atenção!} Esta operação somente deve ser chamada durante o processo de tratamento de requisição do serviço implementado.  

  \item \code{openbusidl::acs::IAccessControlService* \\
Openbus::getAccessControlService()}: Retorna o serviço de acesso.

  \item \code{registry\_service::IRegistryService* getRegistryService()}: Retorna o serviço de registro.

  \item \code{access\_control\_service::Credential* Openbus::getCredential()}: Retorna a credencial de identificação do usuário frente ao barramento.

  \item \code{interceptors::CredentialValidationPolicy \\
   getCredentialValidationPolicy()}: Retorna a política de validação de credenciais.

  \item \code{void setThreadCredential(access\_control\_service::Credential* credential)}: Define uma credencial a ser utilizada no lugar da credencial corrente. Útil para fornecer uma credencial com o campo delegate preenchido.
\textbf{Atenção!} Na versão Orbix este método não considera um comportamento multithread, sendo assim a alteração de credencial será válida para todas as threads.

  \item \code{void setLeaseExpiredCallback(LeaseExpiredCallback* \\ leaseExpiredCallback)}: Registra uma callback para a notificação de lease expirado através de um objeto do tipo LeaseExpiredCallback. Este método deve ser chamado após o estabelecimento da conexão com o barramento.

\begin{labeledcode}[c++]{leaseExpiredCallback}{Definição da classe \emph{LeaseExpiredCallback}}
class LeaseExpiredCallback {
  public:
    virtual void expired() = 0;
};
\end{labeledcode}

A classe \emph{LeaseExpiredCallback}, apresentada no  
código~\ref{lst:leaseExpiredCallback}, representa uma callback para a notificação 
de que o lease da credencial de indentificação do usuário expirou. O usuário 
deve fornecer a implementação da callback implementando o método expired().

  \item \code{void removeLeaseExpiredCallback()}: Remove uma callback previamente registrada para a notificação de lease expirado. Este método deve ser chamado após o estabelecimento da conexão com o barramento.

  \item \code{services::RegistryService* Openbus::connect( const char* user,       const char* password) throw (CORBA::SystemException, LOGIN\_FAILURE)}: Realiza 
uma tentativa de conexão com o barramento. Se a tentativa for bem sucedida, uma 
instância que representa o serviço de registro é retornada, caso contrário duas 
exceções podem ser lançadas:

  \begin{description}
    \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
    \item[CORBA::SystemException] Alguma falha de comunicação com o barramento 
    ocorreu.
    Possíveis causas:
    \begin{itemize}
      \item Os valores que definem a localização do barramento(máquina e porta) 
      estão incorretos.
      \item O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
    \end{itemize}
  \end{description}

  \item \code{services::RegistryService* Openbus::connect(\\
      const char* entity,
      const char* privateKeyFilename,\\
      const char* ACSCertificateFilename)\\
      throw (CORBA::SystemException, LOGIN\_FAILURE, SECURITY\_EXCEPTION)}: 
Realiza uma tentativa de conexão com o barramento utilizando o mecanismo de 
certificação para o processo de autenticação. Se a tentativa for bem 
sucedida, uma instância que representa o serviço de registro é retornada, 
caso contrário duas exceções podem ser lançadas:

  \begin{description}
    \item[LOGIN\_FAILURE] O par nome de usuário e senha não foram validados.
    \item[CORBA::SystemException] Alguma falha de comunicação com obarramento 
    ocorreu. Possíveis causas:
    \begin{itemize}
      \item Os valores que definem a localização do barramento(host e porta) estão incorretos.
      \item O mecanismo de interceptação não está sendo ativado. (rever o ítem 1)
    \end{itemize}
    \item[SECURITY\_EXCEPTION] Falha no mecanismo de autenticação por certificado 
    digital. Algumas possíveis causas:
    \begin{itemize}
      \item Não foi possível obter o desafio.
      \item Falha na manipulação de uma chave privada ou pública.
      \item Falha na manipulação de um certificado.
    \end{itemize}
  \end{description}

  \item \code{bool Openbus::disconnect()}: Desfaz a conexão atual. Caso a conexão seja desfeita, true é retornado, caso contrário, o valor de retorno é false.

  \item \code{void Openbus::run()}: Loop que processa requisições CORBA.   \textbf{Atenção!} Este método na versão Mico multithread faz um \emph{wait()} na RunThread.

  \item \code{void stop()}: Pára de processar requisições CORBA. Finaliza a execução do run. \textbf{Atenção!} Não faz nada na versão Mico multithread.

  \item \code{void finish(bool force)}: Finaliza a execução do ORB.

  \item \code{void setInterceptable(
      string interfaceRepID, 
      string method, 
      bool isInterceptable)}: Define se os métodos de uma determinada interface devem ou não ser interceptados pelo interceptador servidor.

  \item \code{bool isInterceptable(
      string interfaceRepID, 
      string method)}: Consulta se o método está sendo interceptado.

  \item \code{bool isFaultToleranceEnable()}: Consulta se o mecanismo de tolerância a falhas está ativado.
\end{itemize}

\subsection{Tolerância a falhas}

O usuário Orbix pode habilitar um mecanismo de tolerância a falhas em 
requisições remotas destinadas aos serviços básicos do barramento. Para isto, 
é necessário ter em mãos a lista de réplicas disponíveis para o serviço de 
acesso, e, descrevê-las em um arquivo do tipo Lua, como mostra o código~\ref{lst:replicas} 

\begin{labeledcode}[lua]{replicas}{Lista das réplicas do serviço de acesso}
-- replicas.lua
ACSHosts = {
  {"nomeMaquinaA", 2089},
  {"nomeMaquinaB", 4089},
\end{labeledcode}

Essas informações devem ser obtidas com o administrador do barramento. A
habilitação do mecanismo é através do parâmetro de linha de comando
\emph{-OpenbusFTConfigFilename}, que deve receber o caminho relativo ou absoluto
do arquivo acima.

\subsection{Dinâmica da Programação}
Basicamente há dois tipos de aplicações Openbus. Uma que oferta serviços e 
outra que consome serviços. Sendo possível e natural uma aplicação híbrida 
que assuma as duas posições. Para ambos os tipos, existe uma certa 
dinâmica de programação já definida. Justamente a explicitação dessa 
dinâmica que será o objetivo deste tópico. 
Como facilitador, os processos serão demonstrados com base na \emph{demo} Hello. 
Esta demo é composta de um módulo cliente e de outro servidor. O servidor 
oferta um serviço do tipo Hello num determinado barramento, já o cliente 
procura por este serviço no barramento em questão e o utiliza.

\subsection{Conexão com o barramento}
O primeiro passo é firmar uma conexão autenticada com o barramento, o que é 
necessário tanto para o cliente como para o servidor. Para isto é preciso:
\begin{enumerate}
  \item Adquirir a instância que representa o barramento;
  \item Inicializar essa referência que foi adquirida anteriormente;
  \item Efetuar uma autenticação no barramento. Existem dois modos de
  autenticação frente ao barramento:
  \begin{enumerate}
    \item Par usuário e senha. \label{login-senha}
    \item Certificado digital. \label{certificado}
  \end{enumerate}
\end{enumerate}

O primeiro (\ref{login-senha}) é destinado normalmente aos clientes que estão
acessando o barramento através de uma identificação pessoal e intransferível, já
o segundo (\ref{certificado}) é mais adequado a um serviço ou uma aplicação que
não necessita distinguir os usuários que acessam o barramento. No segundo caso, 
o responsável pelo serviço deve encaminhar ao administrador do barramento o 
certificado do serviço, ou seja, um arquivo especial que contenha a chave 
pública do serviço. Em contrapartida o administrador deve fornecer o 
certificado do serviço de controle de acesso. Os códigos
\ref{lst:conexao-certificado} e \ref{lst:conexao-login-senha} ilustram esses
modos de autenticação.

\begin{labeledcode}[c++]{conexao-certificado}{Autenticando-se ao barramento utilizando um certificado}
  openbus::Openbus* bus = Openbus::getInstance();
  bus->init(argc, argv);
  services::RegistryService* registryService = bus->connect("HelloService",
    "HelloService.key", "AccessControlService.crt");
\end{labeledcode}

\begin{labeledcode}[c++]{conexao-login-senha}{Autenticando-se ao barramento utilizando um login e uma senha}
  openbus::Openbus* bus = Openbus::getInstance();
  bus->init(argc, argv);
  services::RegistryService* registryService = bus->connect("tester", "tester");
\end{labeledcode}

\subsection{Serviço de Registro}

Um serviço pode ser disponibilizado no barramento através de uma oferta de 
serviço (\emph{ServiceOffer}), que é uma estrutura que representa o serviço
através de uma lista de propriedades (\emph{Property}) e de uma referência para
um componente (\emph{member}) SCS. 

\begin{labeledcode}[c++]{serviceOffer}{Definição das estruturas \emph{ServiceOffer} e \emph{Property}}
  typedef sequence<string> PropertyValue;
  struct Property {
      string name;
      PropertyValue value;
  };

  typedef sequence<Property> PropertyList;

  struct ServiceOffer {
      PropertyList properties;
      scs::core::IComponent member;
  };
\end{labeledcode}

Através da lista de propriedades é possível caracterizar o serviço. 
A arquitetura do Openbus é baseada no modelo de componentes SCS. O 
serviço é representado por um componente que pode apresentar 
distintas facetas (interfaces). Sendo assim, o primeiro passo para o 
registro de um serviço é criar um componente que represente o serviço 
desejado. 
Uma fábrica de componentes (componentBuilder) pode ser adquirida 
através do método \emph{Openbus::getComponentBuilder()}.  
De posse desta fábrica, o usuário pode criar um componente atribuindo uma 
ou mais facetas, como mostra o código~\ref{lst:fabrica}.

\begin{labeledcode}[c++]{fabrica}{Uso da fábrica para construção de componente}
  /* Fabrica de componentes */
  scs::core::ComponentBuilder* componentBuilder = bus->getComponentBuilder();

  /* Definicao do componente. */
  scs::core::ComponentId componentId;
  componentId.name = "HelloComponent";
  componentId.major_version = '1';
  componentId.minor_version = '0';
  componentId.patch_version = '0';
  componentId.platform_spec = "nenhuma";

  /* Descricao das facetas. */
  std::list<scs::core::ExtendedFacetDescription> extFacets;
  scs::core::ExtendedFacetDescription helloDesc;
  helloDesc.name = "IHello";
  helloDesc.interface_name = "IDL:demoidl/hello/IHello:1.0";
  helloDesc.instantiator = HelloImpl::instantiate;
  helloDesc.destructor = HelloImpl::destruct;
  extFacets.push_back(helloDesc);
  componentContext = componentBuilder->newComponent(extFacets, componentId);
\end{labeledcode}

O serviço a ser registrado no barramento deve ser descrito através de uma 
oferta de serviço, que é representada pela estrutura ServiceOffer. 
Pendura-se nesta estrutura o serviço em si, que é representado através de 
um componente SCS e opcionalmente uma lista de propriedades referentes ao 
mesmo.
As propriedades devem ser descritas através de uma estrutura do tipo lista. 
Como esta lista é uma \emph{sequence} de uma estrutura que possui 
uma outra lista, que é justamente a lista de valores, pois uma chave pode 
estar relacionada a mais de um valor, o preenchimento dos valores desejados 
envolve um número de linhas de código um tanto indesejável. Por este motivo, 
há a classe de auxílio \emph{PropertyListHelper} que tem por objetivo facilitar
o trabalho de construção das listas de propriedades. O código~\ref{lst:lista}
apresenta um exemplo de como criar uma lista que contenha somente uma 
propriedade do tipo chave/valor. Por sua vez, se a classe de auxílio for
utilizada, simplifica-se o código para a construção dessa mesma lista, como
mostra o código~\ref{lst:helperLista}.

\begin{labeledcode}[c++]{lista}{Criação de uma lista com apenas propriedade do tipo chave/valor}
  openbusidl::rs::PropertyList_var p = new openbusidl::rs::PropertyList(1);
  p->length(1);
  openbusidl::rs::Property_var property = new openbusidl::rs::Property;
  property->name = "description";
  openbusidl::rs::PropertyValue_var propertyValue = 
    new openbusidl::rs::PropertyValue(1);

  propertyValue->length(1);
  propertyValue[0] = "Serviço IHello";
  property->value = propertyValue;
  p[0] = property;
\end{labeledcode}

\begin{labeledcode}[c++]{helperLista}{Criação de uma lista com uso da classe \emph{PropertyListHelper}}
  openbus::util::PropertyListHelper* propertyListHelper = 
    new openbus::util::PropertyListHelper();

  /* Criação de uma *oferta de serviço*. */
  registry_service::ServiceOffer serviceOffer;
  serviceOffer.properties = propertyListHelper->getPropertyList();
  serviceOffer.member = componentContext->getIComponent();
  delete propertyListHelper;
\end{labeledcode}

De posse da lista de propriedades e do componente que representa o serviço, 
é possível requisitar o registro do serviço. Vide o código~\ref{lst:register}.

\begin{labeledcode}[c++]{register}{Registrando o Serviço}
registryId = registryService->_cxx_register(serviceOffer);
\end{labeledcode}

Até este ponto, o servidor basicamente se autenticou ao barramento e registrou 
o serviço. O último passo necessário para se finalizar o código do servidor é 
habilitar o processo servidor a escutar as requisições CORBA que serão 
direcionadas para o serviço ofertado. Vide o código~\ref{lst:run}. 

\begin{labeledcode}[c++]{run}{Disparando o processo do servidor para escutar as requisições CORBA}
bus->run();
\end{labeledcode}

\subsection{Processo cliente}

Como o servidor, o cliente necessita se autenticar no barramento, portanto
os mesmos passos aplicados no servidor para a autenticação devem ser 
repetidos, com exceção de que o cliente provavelmente vai desejar se 
autenticar com o barramento através do mecanismo usuário e senha. O código~\ref{lst:connect-client} ilustra essa autenticação no barramento. 

\begin{labeledcode}[c++]{connect-client}{Autenticação no barramento via usuário e senha}
  registryService = bus->connect("tester", "tester");
\end{labeledcode}

Após a conexão bem sucedida com o barramento, o próximo passo é obter o 
serviço desejado. Isso pode ser feito através de uma chamada ao método 
services::RegistryService::find(), como mostra o código~\ref{lst:find}, que
retorna uma lista de ofertas de serviço que implementam a faceta que o usuário
deseja.

\begin{labeledcode}[c++]{find}{Busca do serviço.}
/* Define a lista de facetas que caracteriza o serviço implementado.
*  O trabalho de criação da lista é facilitado pelo uso da classe 
*  FacetListHelper.
*/
openbus::util::FacetListHelper* facetListHelper =
  new openbus::util::FacetListHelper();
facetListHelper->add("IHello");

/* Busca no barramento o serviço desejado.
*  Uma lista de *ofertas de serviço* é retornada para o usuário.
*  OBS.: Neste demo somente há uma oferta de serviço.
*/
registry_service::ServiceOfferList_var serviceOfferList =
  registryService->find(facetListHelper->getFacetList());
delete facetListHelper;

registry_service::ServiceOffer serviceOffer = serviceOfferList[(CORBA::ULong) 0];
\end{labeledcode}

Como visto acima, a oferta de serviço armazena o serviço através de um 
componente SCS. Como este componente pode apresentar diversas facetas, 
o usuário deve informar qual faceta deseja utilizar. No exemplo utilizado, 
somente há uma faceta IHello. O componente oferece um método(getFacet) para que
o usuário possa obter um objeto CORBA que represente o serviço desejado. Vide o código~\ref{lst:getFacet}.

\begin{labeledcode}[c++]{getFacet}{Recuperando a faceta do serviço desejado.}
scs::core::IComponent_var component = serviceOffer.member;
CORBA::Object_var obj = component->getFacet("IDL:demoidl/hello/IHello:1.0");
\end{labeledcode}

De posse do objeto CORBA, o usuário deve efetuar um narrow para mapeá-lo para 
a interface desejada. Vide o código~\ref{lst:narrow}.

\begin{labeledcode}[c++]{narrow}{Realizando o mapeamento para a interface desejada}
demoidl::hello::IHello_var hello = demoidl::hello::IHello::_narrow(obj);
\end{labeledcode}

Daqui em diante o programador estará apto a utilizar o serviço.

\end{document}

