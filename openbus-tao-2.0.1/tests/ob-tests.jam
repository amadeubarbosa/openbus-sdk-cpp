
import common ;
import option ;
import "class" : new ;
import generators ;
import testing ;
import type ;
import toolset ;
import project ;

project.initialize $(__name__) ;
project ob-tests ;

rule init ( )
{
  .openbus-host = [ option.get openbus-host : localhost ] ;
  .openbus-port = [ option.get openbus-port : 2089 ] ;
  .openbus-wrong-port = [ option.get openbus-wrong-port : 2090 ] ;
}

rule openbus-host ( )
{
  return $(.openbus-host) ;
}

rule openbus-port ( )
{
  return $(.openbus-port) ;
}

rule openbus-wrong-port ( )
{
  return $(.openbus-wrong-port) ;
}

rule run ( name : args * : input-files * : requirements * )
{
  return [ testing.run $(name) : -host $(.openbus-host) -port $(.openbus-port)
          -key $(name) $(args)
          : $(input-files) : $(requirements) : run-$(name) ] ;
}

rule run-fail ( name : args * : input-files * : requirements * )
{
  return [ testing.run-fail $(name) : -host $(.openbus-host) -port $(.openbus-port) $(args)
          : $(input-files) : $(requirements) : run-$(name) ] ;
}

class test-generator : generator
{
    import property-set ;

    rule __init__ ( * : * )
    {
        generator.__init__ $(1) : $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
        self.composing = true ;
    }

    rule run ( project name ? : property-set : sources * : multiple ? )
    {
      result = 
        [ construct-result $(sources) : $(project) $(name)-run : $(property-set) ] ;
    }
}

type.register RUN_OB_OUTPUT ;
type.register RUN_OB : : TEST ;

# Use mpi-test-generator to generate MPI tests from sources
generators.register 
  [ new test-generator ob-tests.capture-output : : RUN_OB_OUTPUT ] ;

generators.register-standard testing.expect-success 
  : RUN_OB_OUTPUT : RUN_OB ;

toolset.flags ob-tests.capture-output ARGS <testing.arg> ;
rule capture-output ( target : sources * : properties * )
{
  # Use the standard capture-output rule to run the tests
  testing.capture-output $(target) : $(sources[1]) : $(properties) ;

  if $(sources[2])
  {
    ECHO capture-output both ;
    local x = [ UPDATE_NOW $(sources[2]) ] ;
    ECHO x $(x) ;

    local service-path = [ on $(sources[2]) return $(LOCATE) ] ;
    local service = $(service-path)/$(sources[2]:G=) ;

    ECHO service $(service) ;
    ECHO [ on $(service) return $(PATH_SETUP) ] ;

    prefix = " &\nsleep 1\n" ;

    PATH_SETUP = [ on $(target) return $(PATH_SETUP) ] ;
    PATH_SETUP on $(target) = $(PATH_SETUP)$(service)$(prefix) ;
  }
  else
  {
    ECHO capture-output service ;
  }
}

rule run-coop-test ( source : args * : input-files * : requirements *
     : service : service-args * : service-input-files * : service-requirements *
     : launcher )
{
  args += -key $(source) ;
  service-args += -key $(source) ;

  requirements += <testing.arg>$(args:J=" ") ;
  requirements += [ testing.handle-input-files $(input-files) ] ;

  service-requirements += <testing.arg>$(service-args:J=" ") ;
  service-requirements += [ testing.handle-input-files $(service-input-files) ] ;

  return [ testing.make-test run-ob : $(source) $(service) $(launcher)
          : $(requirements) : $(source)-run ]
   ;
}

